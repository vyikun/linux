<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Linux</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="linux基础命令">Linux基础命令</h1>
<p>[TOC]</p>
<h2 id="bash基础">0. bash基础</h2>
<p><strong>Linux shell 主要分为以下几类</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">交互式<span class="ex">shell</span>，等待用户输入执行的命令(终端操作,需要不断提示）</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">非交互式<span class="ex">shell</span>，执行shell脚本，脚本执行结束后shel自动退出</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">登陆<span class="ex">shell</span>，需要输入用户名和密码才能进入Shell，日常接触的最多的一种</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">非登陆<span class="ex">shell</span>，不需要输入用户和密码就能进入Shell,比如运行bash会开启一个新的会话窗口</a></code></pre></div>
<p>2.bash shell 配置文件介绍（文件主要保存用户的工作环境）</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">个人配置文件: <span class="ex">~/.bash_profile</span>  ~/.bashrc  </a>
<a class="sourceLine" id="cb2-2" data-line-number="2">全局配置文件:<span class="ex">/etc/profile</span> /etc/profile.d/*.sh /etc/bashrc </a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">profile</span>类文件，设定环境变量，登陆前运行的脚本和命令。</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">bashrc</span>类文件，设定本地变量,定义命令别名</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">PS</span>:如果全局配置和个人配置产生冲突，以个人配置为准。</a></code></pre></div>
<p>3.登陆系统后，环境变量配置文件的应用顺序是?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">登陆式<span class="ex">shell</span>配置文件执行顺序：/etc/profile-<span class="op">&gt;</span>/etc/profile.d/*.sh-<span class="op">&gt;</span>/root/.bash_profile-<span class="op">&gt;</span>/etc/bashrc</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">非登录<span class="ex">shelll</span>配置文件执行顺序：/root/.bashrc-<span class="op">&gt;</span>/etc/bashrc-<span class="op">&gt;</span>/etc/profile.d/*.sh</a></code></pre></div>
<p><strong>ps:验证使用echo在每行添加一个文件名输出即可</strong></p>
<h3 id="快捷键">0.1.快捷键</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">ctrl+a</span>          将光标移动到行首</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">ctrl+e</span>          将光标移动到行尾</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">ctrl+k</span>          删除光标后的所有内容</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">ctrl+u</span>          删除光标前的所有内容</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ex">ctrl+w</span>          删除光标之前的内容，按单词进行删除</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ex">ctrl+l</span>          清理屏幕 ==<span class="op">&gt;</span> clear</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ex">ctrl+r</span>          搜索历史执行过的命令（按关键字搜索）</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="ex">ctrl+c</span>          结束当前正在Bash窗口前台运行的程序</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="ex">ctrl+d</span>          退出当前Bash Shell ==<span class="op">&gt;</span>logout</a></code></pre></div>
<h3 id="别名alias">0.2.别名alias</h3>
<p>1.临时设置</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">设置</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">#alias net=&#39;cat /etc/sysconfig/network-scripts/ifcfg-eth0&#39;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">取消</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="bu">unalias</span> net</a></code></pre></div>
<p>2.永久设置</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">当前用户下#<span class="ex">cat</span> ~/.bashrc文件会自动加载，这个文件也指向/etc/bashrc,所以添加在那个文件都可以</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">#设置方法</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="bu">echo</span> <span class="st">&quot;alias net=&#39;cat /etc/sysconfig/network-scripts/ifcfg-eth0&#39;&quot;</span> <span class="op">&gt;&gt;</span>/etc/bashrc</a></code></pre></div>
<h3 id="历史记录history">0.3.历史记录history</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">#使用</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">!<span class="ex">123</span>                #调用history历史记录中123次的操作再次执行</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">!!                  #快速掉用上一条执行过的命令</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">按<span class="ex">ecs</span>在按 .          #快速调取上一条命令的参数</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co">#参数</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ex">-w</span> 保存当前shell执行过的历史命令，至文件中存储默认存放~/.bash_history文件</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ex">-c</span> 清空命令历史记录，不会清空文件      实例：history -c</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="ex">-d</span> 删除命令历史的第n行               实例：history -d 123</a></code></pre></div>
<h3 id="帮助手册-help-man">0.4.帮助手册 –help | man</h3>
<pre><code>ls --help
man ls                      ---&gt;按q退出</code></pre>
<h2 id="文件管理">1.文件管理</h2>
<p><strong>创建/复制/移动/删除/编辑</strong></p>
<h3 id="创建文件-touch">1.1.创建文件 touch</h3>
<pre><code>#touch file                     #无则创建有则修改创建时间
#touch file1 file2  
#touch /home/file3 file4
#touch file{a,b,c}              #{}集合,等价 touch a b c
#touch file{1..10}
#touch file{a..z}</code></pre>
<h3 id="创建目录-mkdir">1.2.创建目录 mkdir</h3>
<p>目录通常显示为蓝色</p>
<pre><code>命令:mkdir
选项: -p递归创建 -v显示创建过程     
参数: 路径,在什么地方创建

#mkdir /home/cc/123 /home/kk/456 -p
#mkdir /home/cc/{dir3,dir4}
#mkdir -pv /home/{cc/{xx,zz},oo}

tree 将目录以树状结构显示,如果没有的话yum instll tree -y 安装</code></pre>
<h3 id="拷贝文件-cp">1.3.拷贝文件 cp</h3>
<pre><code>命令: cp
选项: 
-v:详细显示命令执行的操作 
-r:递归处理目录与文件 
-p:保留源文件或目录的属性</code></pre>
<h3 id="移动文件-mv">1.4.移动文件 mv</h3>
<pre><code>移动文件: mv[OPTION]... SoURCE... DIRECTORY</code></pre>
<h3 id="删除文件或目录-rm">1.5.删除文件或目录 rm</h3>
<pre><code>选项: 
-r:递归 
-f:强制删除 
-v:详细过程</code></pre>
<p>实验:</p>
<pre><code>1.创建了一推的文件，文件要进行分门别类存储起来。
    1)创建一推文件        {/data/filea-filez}
    2)创建一个目录        {/data/files}
    3)将文件拷贝到对应目录
    4)删除文件            {/data/files/*}
</code></pre>
<h3 id="chmod-修改文件权限">1.6.chmod 修改文件权限</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">#选项:  -R递归修改</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co"># chmod 644 file</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co"># chmod -R 755 dir/</span></a></code></pre></div>
<h3 id="chown-修改属主属组">1.7.chown 修改属主属组</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">#选项:  -R递归修改</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ex">1.</span>变更文件的属主和属组</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="fu">chown</span> kk.kk access-2020-03-12.log</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="ex">2.</span>仅变更文件的属组</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">[<span class="ex">root@web</span> ~]# chown .root access-2020-03-12.log</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">[<span class="ex">root@web</span> ~]# ll access-2020-03-12.log</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="ex">-rw-r--r--.</span> 1 kk root 58112885 3月  13 09:25 access-2020-03-12.log</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="ex">3.</span>使用chgrp直接变更文件的属组（只能是属组，不能是其他）</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">[<span class="ex">root@web</span> ~]# chgrp kk access-2020-03-12.log</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">[<span class="ex">root@web</span> ~]# ll access-2020-03-12.log</a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="ex">-rw-r--r--.</span> 1 kk kk 58112885 3月  13 09:25 access-2020-03-12.log</a></code></pre></div>
<h3 id="文件编辑vim">1.7.文件编辑vim</h3>
<p>1.普通模式</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ex">vim</span>一个文件默认是普通模式,主要是控制光标移动,可对文本进行复制、粘贴、删除等工作。</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ex">1</span>、命令行跳转</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ex">G</span>       #光标跳转至未端（文件的尾部）</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ex">gg</span>      #光标跳转至顶端</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="ex">Ngg</span>     #光标跳转至当前文件内的N行  （指定光标跳转到多少行） 5gg 跳转到第五行</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ex">ctrl+f</span>  #往下翻页（行比较多）</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="ex">ctrl+b</span>  #往下翻页</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">$       #光标跳转至当前光标所在行的尾部 （只是跳转，并不会进入编辑模式）</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">^<span class="kw">|</span><span class="ex">0</span>     #光标跳转至当前光标所在行的首部</a>
<a class="sourceLine" id="cb17-11" data-line-number="11"></a>
<a class="sourceLine" id="cb17-12" data-line-number="12"><span class="ex">2</span>、复制粘贴</a>
<a class="sourceLine" id="cb17-13" data-line-number="13"><span class="ex">yy</span>      #复制与当前光标所在的行</a>
<a class="sourceLine" id="cb17-14" data-line-number="14"><span class="ex">Nyy</span>     #复制带上当前光标所在的行，共N行</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16"><span class="ex">p</span>(小写)   #粘贴至当前光标下一行</a>
<a class="sourceLine" id="cb17-17" data-line-number="17"><span class="ex">P</span>(大写)   #粘贴至当前光标上一行</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"><span class="ex">3</span>、删除剪贴撤销</a>
<a class="sourceLine" id="cb17-19" data-line-number="19"><span class="fu">dd</span>      #删除当前光标所在的行</a>
<a class="sourceLine" id="cb17-20" data-line-number="20"><span class="ex">4dd</span>     #删除当前光标所在的行以及往下的3行</a>
<a class="sourceLine" id="cb17-21" data-line-number="21"><span class="ex">dG</span>      #删除当前光标以后的所有行</a>
<a class="sourceLine" id="cb17-22" data-line-number="22"><span class="ex">D</span>       #删除当前光标及光标以后的内容</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"><span class="ex">x</span>       #删除当前光标标记记住往后的字符</a>
<a class="sourceLine" id="cb17-24" data-line-number="24"><span class="ex">X</span>       #删除当前光标标记记住往前的字符</a>
<a class="sourceLine" id="cb17-25" data-line-number="25"><span class="fu">dd</span> <span class="kw">&amp;</span> <span class="ex">p</span>  #剪贴 先删除后粘贴=剪贴</a>
<a class="sourceLine" id="cb17-26" data-line-number="26"><span class="ex">u</span>       #撤销上一次的操作</a>
<a class="sourceLine" id="cb17-27" data-line-number="27"><span class="ex">4</span>、替换</a>
<a class="sourceLine" id="cb17-28" data-line-number="28"><span class="ex">r</span>       #替换当前光标标记的单个字符</a>
<a class="sourceLine" id="cb17-29" data-line-number="29"><span class="ex">R</span>       #进入REPLACE模式，连续替换，ESC结束</a></code></pre></div>
<p>2.编辑模式</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" data-line-number="1">从普通模式进入编辑模式，只需按一个键即可（<span class="ex">i</span>、I、a、A、o、O） esc退出编辑模式</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="ex">i</span>       #进入编辑模式，光标不做任何操作</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ex">a</span>       #进入编辑模式，将当前光标往后一位</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="ex">o</span>       #进入编辑模式，并在当前光标下添加一行空白内容</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ex">I</span>       #进入编辑模式，并且光标会跳转至本行的头部</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ex">A</span>       #进入编辑模式，将光标移动至本行尾部</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ex">O</span>       #进入编辑模式，并在当前光标上添加一行空白内容</a></code></pre></div>
<p>3.末行模式</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" data-line-number="1">在普通模式下,输入 <span class="st">&quot;:&quot;</span> 或者 <span class="st">&quot;/&quot;</span> 即可进入末行模式<span class="ex">.</span>在末行模式下可进行的操作有:显示行号、搜索、替换、保存、退出。</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="co">#主要保存退出</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">:<span class="ex">w</span>          保存当前状态</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">:<span class="ex">q</span>          退出当前文档（文档必须保存才能退出）</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">:<span class="ex">w</span>!         强制保存当前状态</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">:<span class="ex">q</span>!         强制退出文档不会修改文件内容</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">:<span class="ex">wq</span>         先保存在退出</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">:<span class="ex">wq</span>!        强制保存并退出</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">:<span class="ex">number</span>     跳转至对应的行号</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"></a>
<a class="sourceLine" id="cb19-11" data-line-number="11"><span class="ex">2.</span>文件内容查找</a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="ex">/string</span>     #需要搜索的内容（查找）</a>
<a class="sourceLine" id="cb19-13" data-line-number="13"><span class="ex">n</span>           #按搜索到的内容依次往下进行查找</a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="ex">N</span>           #按搜索到的内容依次往上查找</a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="ex">3.</span>文件内容替换</a>
<a class="sourceLine" id="cb19-16" data-line-number="16"></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">:<span class="ex">1</span>,5s#sbin#test#g       #替换1-5行中包含sbin的内容为test</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">:<span class="ex">%S</span>#sbin#test#g         #替换整个文本文件中包含sbin的替换为test</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"><span class="ex">4.</span>文件内容保存</a>
<a class="sourceLine" id="cb19-20" data-line-number="20">:<span class="ex">w</span> /root/test.txt       #将所有内容保存到/root/test.txt文件中</a>
<a class="sourceLine" id="cb19-21" data-line-number="21"></a>
<a class="sourceLine" id="cb19-22" data-line-number="22"><span class="ex">5.</span>文件内容读入</a>
<a class="sourceLine" id="cb19-23" data-line-number="23">:<span class="ex">r</span> /etc/hosts           #读入/etc/hosts文件至当前光标下面</a>
<a class="sourceLine" id="cb19-24" data-line-number="24">:<span class="ex">5r</span> /etc/hosts          #指定插入/etc/hosts文件至当前文件的第五行下面</a></code></pre></div>
<p>4.视图模式</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" data-line-number="1">从普通模式进入视图模式，主要进行批量操作</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="bu">shift</span>+v     进入可视化模式，选中整行内容可进行如下操作：</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="ex">1.</span>复制：选中行内容后按y键即可复制。</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="ex">2.</span>删除：选中行内容后按d键删除。</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="ex">ctrl+v</span>      进入可视快模式，选中需要注释的行</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    <span class="ex">1.</span>插入：按shift+i(就是大写i)进入编辑模式，输入#，结束按<span class="ex">ESC</span>键</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">    <span class="ex">2.</span>删除：选中内容后，按x或者d键删除</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    <span class="ex">3.</span>替换：选中需要替换的内容，按下r键，然后输入替换后的内容</a></code></pre></div>
<p>5.扩展知识</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ex">1.</span>环境变量临时生效</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">:<span class="ex">set</span> nu             #显示行号</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">:<span class="ex">set</span> ic             #忽略大小写,在搜索的时候有用</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">:<span class="ex">set</span> ai             #自动缩进</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">:<span class="ex">set</span> list           #显示制表符(空行、tab键)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">:<span class="ex">noho</span>               #取消搜索出来的内容显示高亮</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">:<span class="ex">set</span> no[nu<span class="kw">|</span><span class="ex">ic</span><span class="kw">|</span><span class="ex">ai..</span>] <span class="co">#取消临时设定的变量</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ex">2.</span>环境变量永久生效. ~/.vimrc 个人环境变量(优先级高) <span class="ex">/etc/vimrc</span> 全局环境变量</a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="co"># vim ~/.vimrc      #当下次再打开文件自动显示行号并忽略大小写</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="kw">set</span> <span class="ex">nu</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13"><span class="kw">set</span> <span class="ex">ic</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14"></a>
<a class="sourceLine" id="cb21-15" data-line-number="15"><span class="co">#如果个人vim环境没有配置,则使用全局vim环境变量配置.</span></a>
<a class="sourceLine" id="cb21-16" data-line-number="16"><span class="co">#如果个人vim环境和全局环境变量产生冲突,优先使用个人vim环境变量.</span></a>
<a class="sourceLine" id="cb21-17" data-line-number="17"><span class="ex">3.</span>如何同时编辑多个文件</a>
<a class="sourceLine" id="cb21-18" data-line-number="18"></a>
<a class="sourceLine" id="cb21-19" data-line-number="19"><span class="ex">vim</span> -o file1 file2      #水平分隔</a>
<a class="sourceLine" id="cb21-20" data-line-number="20"><span class="ex">vim</span> -O file1 file2      #垂直分隔</a>
<a class="sourceLine" id="cb21-21" data-line-number="21"></a>
<a class="sourceLine" id="cb21-22" data-line-number="22"><span class="co">#ctrl+ww    文件切换</span></a>
<a class="sourceLine" id="cb21-23" data-line-number="23"><span class="ex">4.</span>相同文件之间差异对比,通常用于对比修改前后差异</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="co">#diff           #文件对比</span></a>
<a class="sourceLine" id="cb21-26" data-line-number="26"><span class="co">#vimdiff        #以vim方式打开两个文件对比,高亮显示不同的内容</span></a>
<a class="sourceLine" id="cb21-27" data-line-number="27"><span class="ex">5.</span>如果vim非正常退出(ctrl+z)挂起或强制退出终端没关闭<span class="ex">vim</span>后</a>
<a class="sourceLine" id="cb21-28" data-line-number="28"></a>
<a class="sourceLine" id="cb21-29" data-line-number="29">当我们去编辑一个文件的时，有时会出现网络中断、或者自己按了一下<span class="ex">ctrl+z</span>，造成异常情况。</a>
<a class="sourceLine" id="cb21-30" data-line-number="30">    编辑文件时，可以选择<span class="ex">r</span>键。恢复到修改的状态。</a>
<a class="sourceLine" id="cb21-31" data-line-number="31">        可以选择<span class="ex">e</span>键。恢复文件没保存的状态。</a>
<a class="sourceLine" id="cb21-32" data-line-number="32">    记得文件恢复后，记得干掉<span class="ex">.xxx</span>的swp文件 （或者移动走）</a>
<a class="sourceLine" id="cb21-33" data-line-number="33"></a>
<a class="sourceLine" id="cb21-34" data-line-number="34"><span class="co">#假设打开filename文件被意外关闭,需要删除同文件名的.swp文件即可解决</span></a>
<a class="sourceLine" id="cb21-35" data-line-number="35"><span class="co">#rm -f .filename.swp</span></a></code></pre></div>
<h2 id="查看文件内容">2.查看文件内容</h2>
<h3 id="查看文件内容-cat">2.1.查看文件内容 cat</h3>
<pre><code>参数: -n:查看文件内容
     -A:查看文件特殊符号</code></pre>
<h3 id="查看大文件-lessmore">2.2.查看大文件 less、more</h3>
<pre><code>less /etc/services  #使用光标上下翻动，空格进行翻页，q退出
more /etc/services  #使用回车上下翻动，空格进行翻页，q退出</code></pre>
<h3 id="查看文件前十行head">2.3.查看文件前十行head</h3>
<pre><code>默认查看文件前十行
head /etc/passwd

参数： -n5 #查看头部前5行</code></pre>
<h3 id="查看文件后十行-tail">2.4.查看文件后十行 tail</h3>
<pre><code>默认查看文件后十行
tali /etc/passwd

参数： -n5 #查看文件后五行
      -f  #动态查看文件尾部信息 同等talif

tali -f /var/log/secure</code></pre>
<h3 id="过滤文件内容-grep">2.5.过滤文件内容 grep</h3>
<pre><code>grep &quot;root&quot; /etc/passwd     #匹配包含root关键字的行

参数                  示例
^ 以什么开头的行       grep &quot;^root&quot; /etc/passwd
$ 以什么结尾的行       grep &quot;/bin/bash$&quot; /etc/passwd
-v 取反              grep  -v &quot;/bin/bash$&quot; /etc/passwd
-i 忽略大小写         grep -i &quot;root&quot; /etc/passwd
-E 多条件过滤         grep -E &quot;sync|ftp&quot; /etc/passwd


-n 查看过滤的文件所在行 grep -n &quot;root&quot; /etc/passwd

grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配文件中Failed字符串，并打印他的下两行
grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配文件中Failed字符串，并打印他的上两行
grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配文件中Failed字符串，并打印他的上下各两行</code></pre>
<h2 id="下载文件">3.下载文件</h2>
<h3 id="wget-curl-联网下载文件">3.1. wget curl 联网下载文件</h3>
<p><strong>wget</strong></p>
<pre><code>#centos7 系统最小化安装默认没有wget命令，需要安装
#yum install wget -y

#下载互联网上的文件至本地
#wget http://mirrors.aliyun.com/repo/Centos-7.repo

#-o 指定文件下载位置
#wget -o /etc/yum.repos.d/CentOs-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre>
<p><strong>curl</strong></p>
<pre><code>只curl的话只会查看文件内容加-o下载

curl -o /etc/yum.repos.d/CentOs-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre>
<h3 id="rz-sz-上传下载文件">3.2. rz sz 上传下载文件</h3>
<pre><code>yum install lrzsz -y

#sz /opt/cc     下载文件到本地
#rz             上传文件到服务器
</code></pre>
<h2 id="文件或命令查找">4.文件或命令查找</h2>
<h3 id="which-whereis-命令路径查找">4.1. which whereis 命令路径查找</h3>
<pre><code>which ls        #查找ls命令的绝对路径
whereis ls      #查找命令的绝对路径、帮助手册等
whereis -b ls   #-b 仅显示命令的所在路径
type -a ls      #查看命令的绝对路径（包括别名）</code></pre>
<h3 id="sort-文件内容排序">4.2. sort 文件内容排序</h3>
<p>参数</p>
<pre><code>-r：倒叙
-n：按数字排序
-t：指定分割符（默认空格）
-k：指定第几列，指定第几列几字符（指定1,1 3.1,3.3)</code></pre>
<pre><code>练习文件
cat &gt;&gt; file.txt &lt;&lt;EOF
b:3
c:2
a:4
e:5
d:1
f:11
EOF

sort -t &quot;:&quot; -k2 file.txt  #-t指定分割符 -k指定列

sort -t &quot;:&quot; -k2 -n file.txt  #-t指定分割符 -k指定列 -n按阿拉伯数字排序

sort -t &quot;:&quot; -k2 -n -r file.txt  #-t指定分割符 -k指定列 -n按阿拉伯数字排序 -r倒叙最大的在上面

sort -t &quot;:&quot; -k2 -nr file.txt | head -n3  #提取前三
ps：| 管道：将左边命令的输出结果通过管道交给右边命令的输入

练习二：
cat ip.txt
192.168.3.1 00:0F:AF:81:19:1F
192.168.3.2 00:0F:AF:85:6C:25
192.168.3.3 00:0F:AF:85:70:42
192.168.2.20 00:0F:AF:85:55:DE
192.168.2.21 00:0F:AF:85:6C:09
192.168.2.22 00:0F:AF:85:5C:41
192.168.0.151 00:0F:AF:85:6C:F6
192.168.0.152 00:0F:AF:83:1F:65
192.168.0.153 00:0F:AF:85:70:03
192.168.1.10 00:30:15:A2:3B:B6
192.168.1.11 00:30:15:A3:23:B7
192.168.1.12 00:30:15:A2:3A:A1
192.168.1.1 00:0F:AF:81:19:1F
192.168.2.2 00:0F:AF:85:6C:25
192.168.3.3 00:0F:AF:85:70:42
192.168.2.20 00:0F:AF:85:55:DE
192.168.1.21 00:0F:AF:85:6C:09
192.168.2.22 00:0F:AF:85:5C:41
192.168.0.151 00:0F:AF:85:6C:F6
192.168.1.152 00:0F:AF:83:1F:65
192.168.0.153 00:0F:AF:85:70:03
192.168.3.10 00:30:15:A2:3B:B6
192.168.1.11 00:30:15:A3:23:B7
192.168.3.12 00:30:15:A2:3A:A1

sort -t &quot;.&quot; -k3.1,3.1 -k4.1,4.3 -n ip.txt</code></pre>
<h3 id="uniq-去重并统计出现的次数">4.3. uniq 去重并统计出现的次数</h3>
<p>必须配合sort 一起使用，先排序，然后去重统计</p>
<p><strong>参数</strong></p>
<pre><code>-c 计算重复的次数，必须挨着的相同行</code></pre>
<pre><code>练习文件
cat &gt;&gt;file3.txt &lt;&lt;EOF
abc
123
abc
123
EOF

sort file3.txt | uniq   #去重不统计
sort file3.txt | uniq -c    #-c去重统计出现的次数</code></pre>
<h3 id="cut-截取字段-配合简单了解使用sed-swk">4.4. cut 截取字段 配合简单了解使用sed swk</h3>
<pre><code>选项：
-d：指定分割符
-f：数字，取第几列 -f3,6三列和6列
-c：按字符取（空格也算）

1.产生文件
# echo &quot;Im oldxu, is QQ 552408925&quot; &gt; oldboy.txt

2.需求：过滤出oldboy.txt文件里 oldxu以及552408925
3.如何实现：
实现方法1：
[root@oldboy ~]# cut -d &quot; &quot; -f 2,5 oldboy.txt
oldxu, 552408925
[root@oldboy ~]# cut -d &quot; &quot; -f 2,5 oldboy.txt  | sed &#39;s#,##g&#39;
oldxu 552408925

实现方法2：
[root@oldboy ~]# awk  &#39;{print $2,$5}&#39; oldboy.txt
oldxu, 552408925
[root@oldboy ~]# awk  &#39;{print $2,$5}&#39; oldboy.txt | sed &#39;s#,##g&#39;
oldxu 552408925

实现方法3： awk处理
[root@oldboy ~]# awk -F &quot;,&quot; &#39;{print $1,$2}&#39; oldboy.txt  | awk &#39;{print $2,$5}&#39;
oldxu 552408925


[root@oldboy ~]# awk -F &quot;[ ,]&quot; &#39;{print $2,$6}&#39; oldboy.txt
oldxu 552408925

高级用法
[ ,]+   +表示重复   前面的字符一次或多次   
    空格算一个分隔符
    逗号算一个分隔符
    空格和逗号挨在一起，也算一个分隔符
    空格逗号空格，全算一个分隔符
[root@oldboy ~]# awk -F &quot;[ ,]+&quot; &#39;{print $2,$5}&#39; oldboy.txt
oldxu 552408925</code></pre>
<h3 id="wc-统计文件多少行">4.5. wc 统计文件多少行</h3>
<pre><code>选项：
-l  显示文件行数
-c  显示文件字节
-w  显示文件单词</code></pre>
<p>练习统计一个文件有多少行</p>
<pre><code>方法一：
# wc -l /etc/services
11176 /etc/services

方法二：
# cat -n /etc/services |tail -1 |awk &#39;{print $1}&#39;

方法三：
# grep -n &quot;.*&quot; /etc/services |tail -1 |awk -F &quot;:&quot; &#39;{print $1}&#39;

方法四：仅供参考！！！！！！！不纠结
NR: 行号
$0: awk是逐行处理文件的，读入一行，然后将一行的内容赋值给$0变量，
# awk &#39;{print NR,$0}&#39; /etc/services  | tail -1 | awk &#39;{print $1}&#39;
11176
</code></pre>
<p>#练习题: 过滤出/etc/passwd以nologin结尾的内容，并统计有多少行</p>
<pre><code>    过滤： grep   /etc/passwd
    条件： nologin结尾的
    并且：
    统计出现的内容总共有多少行： wc -l

[root@oldboy ~]# grep &quot;nologin$&quot; /etc/passwd | wc -l
19</code></pre>
<p>练习题：</p>
<pre><code>分析如下日志，统计每个域名被访问的次数。
[root@student tmp]# cat &gt;&gt;web.log&lt;&lt;EOF 
http://www.xuliangwei.com/index.html
http://www.xuliangwei.com/1.html
http://post.xuliangwei.com/index.html
http://mp3.xuliangwei.com/index.html
http://www.xuliangwei.com/3.html
http://post.xuliangwei.com/2.html
EOF

思路：
    1.要想办法提取域名
    2.排序，将相同的域名罗列在一起
    3.去重，统计

实现：
[root@oldboy ~]# awk -F &#39;/&#39; &#39;{print $3}&#39; web.log | sort | uniq -c
      1 mp3.xuliangwei.com
      2 post.xuliangwei.com
      3 www.xuliangwei.com

将访问次数最多的排在上面
[root@oldboy ~]# awk -F &#39;/&#39; &#39;{print $3}&#39; web.log | sort | uniq -c  | sort -nr
      3 www.xuliangwei.com
      2 post.xuliangwei.com
      1 mp3.xuliangwei.com


----------------------------下午-------------------------------
习题1: 使用awk取出系统的IP地址，思路如下:
    1.我要取的IP值在哪里     ifconfig
    2.如何缩小取值范围(行)
    3.如何精确具体内容(列)

方式1：
[root@oldboy ~]# ifconfig eth0 | head -2 | tail -1 | awk &#39;{print $2}&#39;
172.16.1.53

方式2：
[root@oldboy ~]# ifconfig eth0 | grep &quot;netmask&quot; | awk &#39;{print $2}&#39;
172.16.1.53


习题2: 将/etc/passwd文件中的第一行中的第一列和最后一列位置进行交换。（自行指定以：为分隔符）
    源文件：root:x:0:0:root:/root:/bin/bash
    改变后：/bin/bash:x:0:0:root:/root:root


习题3: 将/etc/sysconfig/selinux 文件中的SELINUX=enforcing替换成SELINUX=disabled</code></pre>
<h2 id="用户管理">5.用户管理</h2>
<h3 id="useradd-创建用户">5.1.useradd 创建用户</h3>
<div class="sourceCode" id="cb40"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="ex">adduser</span>命令软连接指向useradd命令</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="co">#选项</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="co"># -u    指定要创建的用户UID，不允许冲突</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4"><span class="co"># -g    指定要创建用户默认组</span></a>
<a class="sourceLine" id="cb40-5" data-line-number="5"><span class="co"># -G    指定要创建用户附加组，逗号隔开可添加多个附加组</span></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="co"># -s    指定要创建用户的bash shell</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7"><span class="co"># -c    指定要创建用户的注释信息</span></a>
<a class="sourceLine" id="cb40-8" data-line-number="8"></a>
<a class="sourceLine" id="cb40-9" data-line-number="9"><span class="co"># -d    指定要创建用户的家目录</span></a>
<a class="sourceLine" id="cb40-10" data-line-number="10"><span class="co"># -M    给创建的用户不创建家目录</span></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"><span class="co"># -r    创建系统用户，默认无家目录</span></a>
<a class="sourceLine" id="cb40-12" data-line-number="12"></a>
<a class="sourceLine" id="cb40-13" data-line-number="13"><span class="ex">1.</span>创建kk用户，UID5001，基本组students，附加组sa 注释信息：2021 new student，登录shell:/bin/bash</a>
<a class="sourceLine" id="cb40-14" data-line-number="14"><span class="ex">2.</span>创建mysql系统用户，-M不创建用户的家目录 -s指定nologin使用其他用户无法登录系统</a>
<a class="sourceLine" id="cb40-15" data-line-number="15">方法二：<span class="ex">-M</span>不给用户创建家目录，并指定登录的bash是/sbin/nologin</a></code></pre></div>
<h3 id="usermod-修改用户">5.2.usermod 修改用户</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="co">#选项</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="co"># -u 指定要修改用户的UID</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="co"># -g 指定要修改用户基本组</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="co"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="co"># -d 指定要修改用户家目录</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="co"># -s 指定要修改用户的bash shell</span></a>
<a class="sourceLine" id="cb41-7" data-line-number="7"><span class="co"># -c 指定要修改用户注释信息</span></a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9"><span class="co"># -l 指定要修改用户的登陆名</span></a>
<a class="sourceLine" id="cb41-10" data-line-number="10"><span class="co"># -L 指定要锁定的用户</span></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="co"># -U 指定要解锁的用户</span></a>
<a class="sourceLine" id="cb41-12" data-line-number="12"></a>
<a class="sourceLine" id="cb41-13" data-line-number="13"><span class="co">#4、锁定用户【扩展】</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14"><span class="co"># echo &quot;123&quot; |passwd --stdin username</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15"><span class="co"># usermod -L username  #锁定后会无法登陆系统</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16"></a>
<a class="sourceLine" id="cb41-17" data-line-number="17"><span class="co">#5、解锁用户【扩展】</span></a>
<a class="sourceLine" id="cb41-18" data-line-number="18"><span class="co"># usermod -U username</span></a></code></pre></div>
<h3 id="userdel-删除用户">5.3.userdel 删除用户</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="co">#选项 -r 删除用户的家目录，以及用户的邮件 </span></a></code></pre></div>
<h3 id="passwd-修改用户密码">5.4.passwd 修改用户密码</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ex">1</span>、使用passwd命令修改用户密码</a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="co"># passwd        #给当前用户修改密码</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="co"># passwd root   #给root用户修改密码(只能是root才有此权限，其他任何用户都没有该权限)</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="co"># passwd kk #给kk用户修改密码（root可以，或者kk用户自己给自己修改密码）</span></a>
<a class="sourceLine" id="cb43-5" data-line-number="5"></a>
<a class="sourceLine" id="cb43-6" data-line-number="6"><span class="ex">2</span>、通过passwd --stdin读取输出的结果，将结果赋值给对应的用户</a>
<a class="sourceLine" id="cb43-7" data-line-number="7"><span class="co"># echo &quot;123&quot; | passwd --stdin kk    #非交互式修改密码</span></a></code></pre></div>
<p><strong>PS: 推荐密码保存套件工具，支持windows、MacOS、Iphone以及浏览器插件Lastpass官方网站</strong></p>
<h3 id="mkpasswd-生成随机数">5.5.mkpasswd 生成随机数</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb44-1" data-line-number="1">    选项：</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">    <span class="ex">-l</span>   设定密码长度,</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">    <span class="ex">-d</span>   数子,</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">    <span class="ex">-c</span>   小写字母,</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">    <span class="ex">-C</span>   大写字母,</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">    <span class="ex">-s</span>   特殊字符</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb44-8" data-line-number="8">[<span class="ex">root@docker01</span> ~]# yum install expect -y</a>
<a class="sourceLine" id="cb44-9" data-line-number="9"></a>
<a class="sourceLine" id="cb44-10" data-line-number="10"><span class="co">#注意：各种特殊字符的位数加起来，不能超过-l指定的长度</span></a>
<a class="sourceLine" id="cb44-11" data-line-number="11">[<span class="ex">root@docker01</span> ~]# mkpasswd -l 10 -d 2 -c 3 -C 3 -s 2</a>
<a class="sourceLine" id="cb44-12" data-line-number="12">[<span class="ex">ks1KOmZ8</span>$</a></code></pre></div>
<h3 id="su-sudo提权">5.6. su sudo提权</h3>
<p><strong>1、su 提权</strong></p>
<p><strong>普通用户su -可以直接切换至root用户，但需要输入root用户的密码。 超级管理员root用户使用su - username切换普通用户不需要输入任何密码</strong></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="fu">su</span> - username   属于登陆式shell</a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="fu">su</span>  username    属于非登陆式shell</a>
<a class="sourceLine" id="cb45-3" data-line-number="3">区别在于加载的环境变量不一样</a>
<a class="sourceLine" id="cb45-4" data-line-number="4"></a>
<a class="sourceLine" id="cb45-5" data-line-number="5"><span class="co">#1.普通用户使用su切换root</span></a>
<a class="sourceLine" id="cb45-6" data-line-number="6">[<span class="ex">root@test01</span> home]$ su </a>
<a class="sourceLine" id="cb45-7" data-line-number="7"></a>
<a class="sourceLine" id="cb45-8" data-line-number="8"><span class="co">#2.普通用户使用su -切换到root，会加载root的环境变量</span></a>
<a class="sourceLine" id="cb45-9" data-line-number="9">[<span class="ex">kk@test01</span> home]$ su -</a>
<a class="sourceLine" id="cb45-10" data-line-number="10"></a>
<a class="sourceLine" id="cb45-11" data-line-number="11"><span class="co">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></a>
<a class="sourceLine" id="cb45-12" data-line-number="12">[<span class="ex">root@test01</span> ~]# su - kk -c <span class="st">&#39;ls /home&#39;</span></a></code></pre></div>
<p><strong>2、sudo 提权</strong></p>
<p>1.如何快速埋下hulk的种子呢？</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co">#1.快速配置sudo方式[先睹为快]wheel组</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">[<span class="ex">root@test01</span> ~]# usermod kk -G wheel</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">[<span class="ex">root@test01</span> ~]# id kk</a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="va">uid=</span>1005<span class="va">(</span>kk<span class="va">)</span> <span class="va">gid=</span>1005<span class="va">(</span>kk<span class="va">)</span> <span class="va">groups=</span>1005<span class="va">(</span>kk<span class="va">)</span>,10<span class="va">(</span>wheel<span class="va">)</span></a>
<a class="sourceLine" id="cb46-5" data-line-number="5">[<span class="ex">root@test01</span> ~]# gpasswd -d kk wheel   #删除附加组</a>
<a class="sourceLine" id="cb46-6" data-line-number="6"><span class="ex">Removing</span> user kk from group wheel</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">[<span class="ex">root@test01</span> ~]# id kk</a>
<a class="sourceLine" id="cb46-8" data-line-number="8"><span class="va">uid=</span>1005<span class="va">(</span>kk<span class="va">)</span> <span class="va">gid=</span>1005<span class="va">(</span>kk<span class="va">)</span> <span class="va">groups=</span>1005<span class="va">(</span>kk<span class="va">)</span></a>
<a class="sourceLine" id="cb46-9" data-line-number="9"></a>
<a class="sourceLine" id="cb46-10" data-line-number="10">[<span class="ex">root@node1</span> ~]$ sudo tail -f /var/log/secure    #sudo审计日志</a>
<a class="sourceLine" id="cb46-11" data-line-number="11"></a>
<a class="sourceLine" id="cb46-12" data-line-number="12"><span class="co">#2.一般正常配置sudo方式</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">[<span class="ex">root@test01</span> ~]# <span class="co">#visudo =&gt; vim /etc/sudoers</span></a>
<a class="sourceLine" id="cb46-14" data-line-number="14"><span class="co">#1.用户名  2.主机名=(角色名）       4.命令名</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15"><span class="ex">bgx</span>       ALL=(ALL)         <span class="ex">/usr/bin</span>/<span class="ex">yum</span>,/usr/sbin/useradd   #允许使用sudo执行命令</a>
<a class="sourceLine" id="cb46-16" data-line-number="16"><span class="ex">oldboy</span>   ALL=(ALL)          <span class="ex">NOPASSWD</span>:/bin/cp, /bin/rm   #NOPASSWD不需要使用密码</a></code></pre></div>
<p>2.埋下了hulk种子后又如何提权使用呢？</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">#1.切换普通用户</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">[<span class="ex">root@test01</span> ~]# su - kk</a>
<a class="sourceLine" id="cb47-3" data-line-number="3"></a>
<a class="sourceLine" id="cb47-4" data-line-number="4"><span class="co">#2.检查普通用户能提权的命令</span></a>
<a class="sourceLine" id="cb47-5" data-line-number="5">[<span class="ex">root@test01</span> ~]$ sudo -l</a>
<a class="sourceLine" id="cb47-6" data-line-number="6"><span class="ex">User</span> kk may run the following commands on this host:</a>
<a class="sourceLine" id="cb47-7" data-line-number="7">    <span class="kw">(</span><span class="ex">ALL</span><span class="kw">)</span> <span class="ex">ALL</span></a>
<a class="sourceLine" id="cb47-8" data-line-number="8"></a>
<a class="sourceLine" id="cb47-9" data-line-number="9"><span class="co">#3.普通用户正常情况下是无法删除opt目录的</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10">[<span class="ex">root@test01</span> ~]$ rm -rf /opt/</a>
<a class="sourceLine" id="cb47-11" data-line-number="11"><span class="ex">rm</span>: cannot remove <span class="kw">`</span>/opt: <span class="ex">Permission</span> denied</a>
<a class="sourceLine" id="cb47-12" data-line-number="12"></a>
<a class="sourceLine" id="cb47-13" data-line-number="13"><span class="co">#4.使用sudo提权，需要输入普通用户的密码。</span></a>
<a class="sourceLine" id="cb47-14" data-line-number="14">[<span class="ex">root@test01</span> ~]$ sudo rm -rf /opt</a></code></pre></div>
<p><strong>3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</strong></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb48-1" data-line-number="1">第一种方式:使用<span class="ex">sudo</span>中自带的别名操作,将多个用户定义成一个组,这个组只有sudo认可</a>
<a class="sourceLine" id="cb48-2" data-line-number="2"><span class="co">#编辑sudo配置</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">[<span class="ex">root@test01</span> ~]# visudo </a>
<a class="sourceLine" id="cb48-4" data-line-number="4">​</a>
<a class="sourceLine" id="cb48-5" data-line-number="5"><span class="co"># 1.使用sudo定义分组,这个系统group没什么关系</span></a>
<a class="sourceLine" id="cb48-6" data-line-number="6"><span class="ex">User_Alias</span> OPS = qq,ww</a>
<a class="sourceLine" id="cb48-7" data-line-number="7"><span class="ex">User_Alias</span> DBA = kk,gg</a>
<a class="sourceLine" id="cb48-8" data-line-number="8">​</a>
<a class="sourceLine" id="cb48-9" data-line-number="9"><span class="co"># 2.定义可执行的命令组, 便于后续调用</span></a>
<a class="sourceLine" id="cb48-10" data-line-number="10"><span class="ex">Cmnd_Alias</span> NETWORKING = /sbin/ifconfig, /bin/ping</a>
<a class="sourceLine" id="cb48-11" data-line-number="11"><span class="ex">Cmnd_Alias</span> SOFTWARE = /bin/rpm, /usr/bin/yum</a>
<a class="sourceLine" id="cb48-12" data-line-number="12"><span class="ex">Cmnd_Alias</span> SERVICES = /sbin/service, /usr/bin/systemctl start</a>
<a class="sourceLine" id="cb48-13" data-line-number="13"><span class="ex">Cmnd_Alias</span> STORAGE = /bin/mount, /bin/umount</a>
<a class="sourceLine" id="cb48-14" data-line-number="14"><span class="ex">Cmnd_Alias</span> DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</a>
<a class="sourceLine" id="cb48-15" data-line-number="15"><span class="ex">Cmnd_Alias</span> PROCESSES = /bin/nice, /bin/kill, /usr/bin/kill, /usr/bin/killall</a>
<a class="sourceLine" id="cb48-16" data-line-number="16">​</a>
<a class="sourceLine" id="cb48-17" data-line-number="17"><span class="co"># 3.使用sudo开始分配权限</span></a>
<a class="sourceLine" id="cb48-18" data-line-number="18"><span class="ex">OPS</span>  ALL=(ALL) <span class="ex">NETWORKING</span>,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</a>
<a class="sourceLine" id="cb48-19" data-line-number="19"><span class="ex">DBA</span>  ALL=(ALL) <span class="ex">SOFTWARE</span>,PROCESSES</a>
<a class="sourceLine" id="cb48-20" data-line-number="20">​</a>
<a class="sourceLine" id="cb48-21" data-line-number="21"><span class="co">#4.登陆对应的用户使用 sudo -l 验证权限</span></a>
<a class="sourceLine" id="cb48-22" data-line-number="22">方式二：针对系统中真实的组来进行操作</a></code></pre></div>
<h3 id="bash-4.1-恢复">5.7.-bash-4.1$ 恢复</h3>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2"><span class="ex">-bash-4.1</span>$ cp -a /etc/skel/.bash* ./</a>
<a class="sourceLine" id="cb49-3" data-line-number="3"><span class="ex">-bash-4.1</span>$ exit</a>
<a class="sourceLine" id="cb49-4" data-line-number="4">[<span class="ex">root@text01</span> ~]#   #重新连接即可恢复</a></code></pre></div>
<h2 id="组管理">6.组管理</h2>
<h3 id="groupadd-创建组">6.1.groupadd 创建组</h3>
<div class="sourceCode" id="cb50"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="co">#选项</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="co"># -u 指定要创建用户的UID,不允许冲突</span></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="co"># -g 指定要创建用户默认组</span></a>
<a class="sourceLine" id="cb50-4" data-line-number="4"><span class="co"># -G 指定要创建用户附加组,逗号隔开可添加多个附加组</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"><span class="co"># -d 指定要创建用户家目录</span></a>
<a class="sourceLine" id="cb50-6" data-line-number="6"><span class="co"># -s 指定要创建用户的bash shell</span></a>
<a class="sourceLine" id="cb50-7" data-line-number="7"><span class="co"># -c 指定要创建用户注释信息</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8"><span class="co"># -M 给创建的用户不创建家目录</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9"><span class="co"># -r 创建系统账户，默认无家目录</span></a></code></pre></div>
<h3 id="groupmod-修改组">6.2.groupmod 修改组</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="co">#选项</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2"><span class="co"># -u 指定要修改用户的UID</span></a>
<a class="sourceLine" id="cb51-3" data-line-number="3"><span class="co"># -g 指定要修改用户基本组</span></a>
<a class="sourceLine" id="cb51-4" data-line-number="4"><span class="co"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span></a>
<a class="sourceLine" id="cb51-5" data-line-number="5"><span class="co"># -d 指定要修改用户家目录</span></a>
<a class="sourceLine" id="cb51-6" data-line-number="6"><span class="co"># -s 指定要修改用户的bash shell</span></a>
<a class="sourceLine" id="cb51-7" data-line-number="7"><span class="co"># -c 指定要修改用户注释信息</span></a>
<a class="sourceLine" id="cb51-8" data-line-number="8"><span class="co"># -l 指定要修改用户的登陆名</span></a>
<a class="sourceLine" id="cb51-9" data-line-number="9"><span class="co"># -L 指定要锁定的用户</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10"><span class="co"># -U 指定要解锁的用户</span></a></code></pre></div>
<h3 id="groupdel-删除组">6.3.groupdel 删除组</h3>
<div class="sourceCode" id="cb52"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="co">#选项 -r 删除用户同时删除它的家目录</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">[<span class="ex">root@oldboy</span> ~]# useradd ttboy -g active_gid</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">[<span class="ex">root@oldboy</span> ~]# useradd ggboy -G active_gid</a>
<a class="sourceLine" id="cb52-4" data-line-number="4"></a>
<a class="sourceLine" id="cb52-5" data-line-number="5">[<span class="ex">root@oldboy</span> ~]# grep <span class="st">&quot;active_gid&quot;</span> /etc/group</a>
<a class="sourceLine" id="cb52-6" data-line-number="6"><span class="ex">active_gid</span>:x:12345:ggboy</a>
<a class="sourceLine" id="cb52-7" data-line-number="7"></a>
<a class="sourceLine" id="cb52-8" data-line-number="8"></a>
<a class="sourceLine" id="cb52-9" data-line-number="9">[<span class="ex">root@oldboy</span> ~]# groupdel active_gid</a>
<a class="sourceLine" id="cb52-10" data-line-number="10"><span class="ex">groupdel</span>：不能移除用户“ttboy”的主组</a>
<a class="sourceLine" id="cb52-11" data-line-number="11"></a>
<a class="sourceLine" id="cb52-12" data-line-number="12"><span class="co">#移除主要的成员，就能删除该组</span></a>
<a class="sourceLine" id="cb52-13" data-line-number="13">[<span class="ex">root@oldboy</span> ~]# userdel ttboy</a>
<a class="sourceLine" id="cb52-14" data-line-number="14">[<span class="ex">root@oldboy</span> ~]# groupdel active_gid</a>
<a class="sourceLine" id="cb52-15" data-line-number="15"></a>
<a class="sourceLine" id="cb52-16" data-line-number="16">[<span class="ex">root@oldboy</span> ~]# id ggboy</a>
<a class="sourceLine" id="cb52-17" data-line-number="17"><span class="va">uid=</span>6009<span class="va">(</span>ggboy<span class="va">)</span> <span class="va">gid=</span>12346<span class="va">(</span>ggboy<span class="va">)</span> 组=<span class="ex">12346</span>(ggboy)</a>
<a class="sourceLine" id="cb52-18" data-line-number="18"></a>
<a class="sourceLine" id="cb52-19" data-line-number="19"><span class="co">#1.删除user1用户，但不删除用户家目录和 mail spool</span></a>
<a class="sourceLine" id="cb52-20" data-line-number="20">[<span class="ex">root@bgx</span> ~]# userdel user1</a>
<a class="sourceLine" id="cb52-21" data-line-number="21"></a>
<a class="sourceLine" id="cb52-22" data-line-number="22"><span class="co">#2.-r参数可以连同用户家目录一起删除(慎用)</span></a>
<a class="sourceLine" id="cb52-23" data-line-number="23">[<span class="ex">root@bgx</span> ~]# userdel -r user1</a>
<a class="sourceLine" id="cb52-24" data-line-number="24"></a>
<a class="sourceLine" id="cb52-25" data-line-number="25">注意：删除一个组，必须确保该组的主要成员已经移除该组，就可以正常删除。（附加进来的成员无需考虑在内。）</a></code></pre></div>
<h2 id="权限管理">7.权限管理</h2>
<h3 id="chmod-修改文件rwx权限">7.1chmod 修改文件rwx权限</h3>
<div class="sourceCode" id="cb53"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="co">#-R参数递归修改</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="co">#针对目录设定权限</span></a>
<a class="sourceLine" id="cb53-3" data-line-number="3">[<span class="ex">root@web</span> ~]# mkdir dir</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">[<span class="ex">root@web</span> ~]# chmod 777 dir/    #修改目录允许所有人访问</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">[<span class="ex">root@web</span> ~]# chmod -R 755 dir/ <span class="co">#修改目录及子目录权限</span></a>
<a class="sourceLine" id="cb53-6" data-line-number="6">[<span class="ex">root@web</span> ~]# ll -d dir/</a>
<a class="sourceLine" id="cb53-7" data-line-number="7"><span class="ex">drwxr-xr-x</span> 2 root root 6 Apr 13 03:34 dir/</a>
<a class="sourceLine" id="cb53-8" data-line-number="8"></a>
<a class="sourceLine" id="cb53-9" data-line-number="9">针对 <span class="ex">hr</span> 部门的访问目录/home/hr 设置权限，要求如下:</a>
<a class="sourceLine" id="cb53-10" data-line-number="10"><span class="ex">1.root</span> 用户和 hr 组的员工可以读、写、执行</a>
<a class="sourceLine" id="cb53-11" data-line-number="11"><span class="ex">2.</span>其他用户没有任何权限</a>
<a class="sourceLine" id="cb53-12" data-line-number="12"></a>
<a class="sourceLine" id="cb53-13" data-line-number="13">[<span class="ex">root@web</span> ~]# groupadd hr</a>
<a class="sourceLine" id="cb53-14" data-line-number="14">[<span class="ex">root@web</span> ~]# useradd hr01 -G hr</a>
<a class="sourceLine" id="cb53-15" data-line-number="15">[<span class="ex">root@web</span> ~]# useradd hr02 -G hr</a>
<a class="sourceLine" id="cb53-16" data-line-number="16">[<span class="ex">root@web</span> ~]# useradd hr03</a>
<a class="sourceLine" id="cb53-17" data-line-number="17">[<span class="ex">root@web</span> ~]# mkdir /home/hr</a>
<a class="sourceLine" id="cb53-18" data-line-number="18">[<span class="ex">root@web</span> ~]# chgrp hr /home/hr</a>
<a class="sourceLine" id="cb53-19" data-line-number="19">[<span class="ex">root@web</span> ~]# chmod 770 /home/hr</a>
<a class="sourceLine" id="cb53-20" data-line-number="20">[<span class="ex">root@web</span> ~]# ll -d /home/hr</a>
<a class="sourceLine" id="cb53-21" data-line-number="21"><span class="ex">drwxrwx---</span> 2 root hr 6 Apr 13 03:26 /home/hr</a>
<a class="sourceLine" id="cb53-22" data-line-number="22"></a>
<a class="sourceLine" id="cb53-23" data-line-number="23"></a>
<a class="sourceLine" id="cb53-24" data-line-number="24"></a>
<a class="sourceLine" id="cb53-25" data-line-number="25"><span class="ex">hr01</span>和hr02都能完成如下操作</a>
<a class="sourceLine" id="cb53-26" data-line-number="26">    <span class="fu">touch</span> /home/hr/file</a>
<a class="sourceLine" id="cb53-27" data-line-number="27">    <span class="ex">ll</span> /home/hr</a>
<a class="sourceLine" id="cb53-28" data-line-number="28"></a>
<a class="sourceLine" id="cb53-29" data-line-number="29"><span class="ex">hr03</span>： 他不会这个目录的所属主，也不是hr组的成员，所以按照其他权限的身份去访问：</a>
<a class="sourceLine" id="cb53-30" data-line-number="30">    其他人的权限身份 <span class="ex">---</span> ，所以 hr03 没有任何的权限</a>
<a class="sourceLine" id="cb53-31" data-line-number="31">    <span class="ex">hr03</span>用户无法进入 /home/hr   也无法 ls /home/hr 浏览</a>
<a class="sourceLine" id="cb53-32" data-line-number="32"></a>
<a class="sourceLine" id="cb53-33" data-line-number="33">       因为<span class="ex">hr03</span>用户，既不是属主身份，也不是他的属组身份，所以就按照其他人的身份访问，就要受到其他人权限约束</a></code></pre></div>
<h3 id="chown-修改文件属主属组">7.2 chown 修改文件属主属组</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="co">#参数-R 递归修改</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2"></a>
<a class="sourceLine" id="cb54-3" data-line-number="3"><span class="co">#1.变更文件的属主和属组</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4">[<span class="ex">root@web</span> ~]# chown kk.kk access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-5" data-line-number="5">[<span class="ex">root@web</span> ~]# ll access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-6" data-line-number="6"><span class="ex">-rw-r--r--.</span> 1 kk kk 58112885 3月  13 09:25 access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-7" data-line-number="7"></a>
<a class="sourceLine" id="cb54-8" data-line-number="8"><span class="co">#2.仅变更文件的属组</span></a>
<a class="sourceLine" id="cb54-9" data-line-number="9">[<span class="ex">root@web</span> ~]# chown .root access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-10" data-line-number="10">[<span class="ex">root@web</span> ~]# ll access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-11" data-line-number="11"><span class="ex">-rw-r--r--.</span> 1 kk root 58112885 3月  13 09:25 access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-12" data-line-number="12"></a>
<a class="sourceLine" id="cb54-13" data-line-number="13"><span class="co">#3.使用chgrp直接变更文件的属组（只能是属组，不能是其他）</span></a>
<a class="sourceLine" id="cb54-14" data-line-number="14"></a>
<a class="sourceLine" id="cb54-15" data-line-number="15">[<span class="ex">root@web</span> ~]# chgrp kk access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-16" data-line-number="16">[<span class="ex">root@web</span> ~]# ll access-2020-03-12.log</a>
<a class="sourceLine" id="cb54-17" data-line-number="17"><span class="ex">-rw-r--r--.</span> 1 kk kk 58112885 3月  13 09:25 access-2020-03-12.log</a></code></pre></div>
<h3 id="特殊权限-suid-sgid-sbit">7.3 特殊权限 suid sgid sbit</h3>
<div class="sourceCode" id="cb55"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb55-1" data-line-number="1">文件权限标志 <span class="ex">suid</span>（Set User ID），sgid（Set Group ID）和 sbit（Sticky Bit）是 UNIX 和类 UNIX 操作系统下一些特殊权限，用于处理特定场景的文件访问和执行。以下是对这些权限的简要说明：</a>
<a class="sourceLine" id="cb55-2" data-line-number="2"></a>
<a class="sourceLine" id="cb55-3" data-line-number="3"><span class="co">#suid (Set User ID):</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4">当一个可执行文件具有 <span class="ex">suid</span> 权限，并被执行时，进程的有效用户 ID 将被设置为文件所有者的用户 ID。这意味着，运行该程序的用户将获得与文件所有者相同的访问权限。</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">通常适用于允许非特权用户执行特权任务的情况。</a>
<a class="sourceLine" id="cb55-6" data-line-number="6">使用 <span class="fu">chmod</span> u+s filename 或 chmod 4xxx（原权限） filename 给某个文件设置 suid 标志。</a>
<a class="sourceLine" id="cb55-7" data-line-number="7">使用 <span class="fu">ls</span> 命令时，文件权限中的 <span class="st">&quot;x&quot;</span>（执行权限）将被替换为 <span class="st">&quot;s&quot;</span>。</a>
<a class="sourceLine" id="cb55-8" data-line-number="8"></a>
<a class="sourceLine" id="cb55-9" data-line-number="9"><span class="co">#sgid (Set Group ID):</span></a>
<a class="sourceLine" id="cb55-10" data-line-number="10">当一个可执行文件具有 <span class="ex">sgid</span> 权限，并被执行时，进程的有效组 ID 将被设置为文件所有者的组 ID。与 suid 类似，执行程序的用户将获得与文件所有者同组用户的访问权限。</a>
<a class="sourceLine" id="cb55-11" data-line-number="11">当在目录上设置 <span class="ex">sgid</span> 标志时，新建的子目录和文件将继承目录的组 ID，而不是使用创建它们的用户的组 ID。</a>
<a class="sourceLine" id="cb55-12" data-line-number="12">使用 <span class="fu">chmod</span> g+s filename 或 chmod 2xxx（原权限） filename 给某个文件或目录设置 sgid 标志。</a>
<a class="sourceLine" id="cb55-13" data-line-number="13">使用 <span class="fu">ls</span> 命令时，文件权限中的 <span class="st">&quot;x&quot;</span>（执行权限）将被替换为 <span class="st">&quot;s&quot;</span>。</a>
<a class="sourceLine" id="cb55-14" data-line-number="14"></a>
<a class="sourceLine" id="cb55-15" data-line-number="15"><span class="co">#sbit (Sticky Bit):</span></a>
<a class="sourceLine" id="cb55-16" data-line-number="16">通常在目录上设置。<span class="ex">Sticky</span> Bit 用于保护目录下的文件和子目录。 当在目录上设置 Sticky Bit 标志时，只有文件或子目录的所有者、目录的所有者和 root 用户才能重命名、移动或删除其中的文件和子目录。 其他用户即使拥有写入权限也无法进行此类操作。</a>
<a class="sourceLine" id="cb55-17" data-line-number="17">使用 <span class="fu">chmod</span> o+t dirname 或 chmod 1xxx（原权限） dirname 给某个目录设置 Sticky Bit 标志。</a>
<a class="sourceLine" id="cb55-18" data-line-number="18">使用 <span class="fu">ls</span> 命令时，文件权限中的 <span class="st">&quot;x&quot;</span>（执行权限）将被替换为 <span class="st">&quot;t&quot;</span>。</a>
<a class="sourceLine" id="cb55-19" data-line-number="19">在 <span class="ex">UNIX</span> 和类 UNIX 操作系统下通过命令 ls -l 可以查看文件的权限，这些特殊权限可显示为 <span class="st">&quot;s&quot;</span> 或 <span class="st">&quot;t&quot;</span>，取决于具体设置的标志。</a></code></pre></div>
<h2 id="重定向">8.重定向</h2>
<p>当<strong>运行一个程序</strong>时通常会自动打开<strong>三个标准文件</strong>，分别是标准输入、标准输出、错误输出</p>
<pre class="undefined"><code>标准输入：键盘，输入的内容，或者是通过其他方式读入的内容
标准输出：当执行命令，返回的正确结果
错误输出：当执行命令，返回的错误结果</code></pre>
<h3 id="输出重定向">8.1 输出重定向</h3>
<p><strong>输出重定向，改变输出内容的位置。输出重定向有如下几种方式，如表格所示</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">类型</th>
<th style="text-align: left;">操作符</th>
<th style="text-align: left;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">标准覆盖输出重定向</td>
<td style="text-align: left;">&gt;</td>
<td style="text-align: left;">将程序输出的正确结果输出到指定的文件中,会覆盖文件原有的内容</td>
</tr>
<tr class="even">
<td style="text-align: left;">标准追加输出重定向</td>
<td style="text-align: left;">&gt;&gt;</td>
<td style="text-align: left;">将程序输出的正确结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">错误覆盖输出重定向</td>
<td style="text-align: left;">2&gt;</td>
<td style="text-align: left;">将程序的错误结果输出到执行的文件中，会覆盖文件原有的内容</td>
</tr>
<tr class="even">
<td style="text-align: left;">错误追加输出重定向</td>
<td style="text-align: left;">2&gt;&gt;</td>
<td style="text-align: left;">将程序输出的错误结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">标准输入重定向</td>
<td style="text-align: left;">&lt;&lt;</td>
<td style="text-align: left;">将命令中接收输入的途径由默认的键盘更改为指定的文件或命令</td>
</tr>
</tbody>
</table>
<pre><code>请解释如下重定向含义：

    &gt;       标准正确输出   （ 覆盖 ）
    &gt;&gt;      标准正确输出   （ 追加 ）
    &amp;&gt;      混合输出（标准输出、标准错误输出）   （ 覆盖 ）
    &amp;&gt;&gt;     混合输出（标准输出、标准错误输出）   （ 追加 ）
    2&gt;      标准错误输出  （ 覆盖 ）
    2&gt;&gt;     标准错误输出  （ 追加 ）
    1&gt; te.txt 2&gt;&amp;1  正确和错误都输入到相同位置 错误-&gt;标准输出-&gt;te.txt  ( 覆盖，标准输出是覆盖的 )
    1&gt;&gt;te.txt 2&gt;&amp;1                      错误-&gt;标准输出-&gt;&gt;te.txt   ( 追加，标准输出是追加的 )</code></pre>
<h3 id="输入重定向">8.2 输入重定向</h3>
<p><strong>输入重定向，即原本从键盘等上获得的输入信息，重定向由命令的输出作为输入。&lt; ==0&lt;</strong></p>
<pre><code>案例1: 从文件中读入输入的操作 
案例2:mysql如何恢复备份
案例3: 利用重定向建立多行数据的文件
</code></pre>
<h3 id="管道技术-teexargs">8.3 管道技术 tee、xargs</h3>
<p><strong>管道操作符号 “|” ，主要用来连接左右两个命令, 将左侧的命令的标准输出, 交给右侧命令的标准输</strong></p>
<p><strong>1、tee</strong></p>
<p><strong>tee将管道执行的结果保存一份并向后传递</strong></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="co">#选项: -a追加</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"></a>
<a class="sourceLine" id="cb59-3" data-line-number="3"><span class="ex">tee</span>和重定向的区别？</a>
<a class="sourceLine" id="cb59-4" data-line-number="4"></a>
<a class="sourceLine" id="cb59-5" data-line-number="5">[<span class="ex">root@xuliangwei</span> ~]# date <span class="op">&gt;</span> 1.txt    #将date命令的输出结果写入到1.txt中</a>
<a class="sourceLine" id="cb59-6" data-line-number="6"></a>
<a class="sourceLine" id="cb59-7" data-line-number="7">[<span class="ex">root@xuliangwei</span> ~]# date <span class="kw">|</span> <span class="fu">tee</span> 1.txt <span class="co">#命令执行会输出至屏幕，但会同时保存一份至1.txt文件中</span></a></code></pre></div>
<h3 id="xargs">2.xargs</h3>
<p><strong>xargs参数传递，主要让一些不支持管道的命令可以使用管道技术</strong></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="co"># which cat|xargs ls- l</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"></a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="co"># ls |xargs rm -fv</span></a></code></pre></div>
<h2 id="find-文件查找">9. find 文件查找</h2>
<h3 id="查找示例">9.1 查找示例</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="co">#参数:</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="ex">-name</span>   文件名称查找</a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="ex">-iname</span>  忽略大小写</a>
<a class="sourceLine" id="cb61-4" data-line-number="4"><span class="ex">-size</span>   文件大小查找</a>
<a class="sourceLine" id="cb61-5" data-line-number="5"><span class="ex">-type</span>   文件类型查找 f文件 d目录 l连接 b块设备 c字符设备 s套接字</a>
<a class="sourceLine" id="cb61-6" data-line-number="6"><span class="ex">-mtime</span>  时间查找</a>
<a class="sourceLine" id="cb61-7" data-line-number="7">打印当天的文件===计不计算本地当天时间文件</a>
<a class="sourceLine" id="cb61-8" data-line-number="8"><span class="co">#2.查找7天以前的文件(不会打印当天的文件)=====( 保留了最近7天的数据)</span></a>
<a class="sourceLine" id="cb61-9" data-line-number="9"><span class="co"># find ./ -iname &quot;file-*&quot; -mtime +7</span></a>
<a class="sourceLine" id="cb61-10" data-line-number="10"></a>
<a class="sourceLine" id="cb61-11" data-line-number="11"><span class="co">#3.查找最近7天的文件，不建议使用(会打印当天的文件[当天时间计算])</span></a>
<a class="sourceLine" id="cb61-12" data-line-number="12"><span class="co"># find ./ -iname &quot;file-*&quot; -mtime -7</span></a>
<a class="sourceLine" id="cb61-13" data-line-number="13"></a>
<a class="sourceLine" id="cb61-14" data-line-number="14"><span class="co">#4.查找第7天文件(不会打印当天的文件)</span></a>
<a class="sourceLine" id="cb61-15" data-line-number="15"><span class="co"># find ./ -iname &quot;file-*&quot; -mtime 7</span></a>
<a class="sourceLine" id="cb61-16" data-line-number="16"></a>
<a class="sourceLine" id="cb61-17" data-line-number="17"><span class="co">#5.本地文件保留最近7天的备份文件, 备份服务器保留3个月的备份文件(实际使用方案)</span></a>
<a class="sourceLine" id="cb61-18" data-line-number="18"><span class="fu">find</span> /backup/ -iname <span class="st">&quot;*.bak&quot;</span> -mtime +7 -delete</a>
<a class="sourceLine" id="cb61-19" data-line-number="19"><span class="fu">find</span> /backup/ -iname <span class="st">&quot;*.bak&quot;</span> -mtime +90 -delete</a>
<a class="sourceLine" id="cb61-20" data-line-number="20"></a>
<a class="sourceLine" id="cb61-21" data-line-number="21"><span class="ex">-user</span>   属主查询</a>
<a class="sourceLine" id="cb61-22" data-line-number="22"><span class="ex">-group</span>  属组查询</a>
<a class="sourceLine" id="cb61-23" data-line-number="23"></a>
<a class="sourceLine" id="cb61-24" data-line-number="24"><span class="co">#两个参数之间的关联</span></a>
<a class="sourceLine" id="cb61-25" data-line-number="25"><span class="ex">-a</span>  并且关系，两个条件同时满足</a>
<a class="sourceLine" id="cb61-26" data-line-number="26"><span class="ex">-o</span>  或关系，满足一个即可匹配</a>
<a class="sourceLine" id="cb61-27" data-line-number="27">!   非 <span class="ex">not</span></a></code></pre></div>
<h3 id="查找后处理动作查看列出拷贝删除等">9.2 查找后处理动作（查看、列出、拷贝、删除等）</h3>
<p><strong>find动作处理，比如查找到一个文件后，需要对文件进行如何处理, find的默认动作是 -print</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">动作</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">-print</td>
<td style="text-align: left;">打印查找到的内容(默认)</td>
</tr>
<tr class="even">
<td style="text-align: left;">-ls</td>
<td style="text-align: left;">以长格式显示的方式打印查找到的内容</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-delete</td>
<td style="text-align: left;">删除查找到的文件(仅能删除空目录)</td>
</tr>
<tr class="even">
<td style="text-align: left;">-ok</td>
<td style="text-align: left;">后面跟自定义 shell 命令(会提示是否操作)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-exec</td>
<td style="text-align: left;">后面跟自定义 shell 命令(标准写法 -exec 😉</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb62"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="co">#ps：-exec和xargs删除区别</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2"><span class="bu">exec</span>  一个一个的删除</a>
<a class="sourceLine" id="cb62-3" data-line-number="3">    <span class="fu">rm</span> -f ifcfg-eth0</a>
<a class="sourceLine" id="cb62-4" data-line-number="4">    <span class="fu">rm</span> -f ifcfg-eth1</a>
<a class="sourceLine" id="cb62-5" data-line-number="5">    <span class="fu">rm</span> -f ifcfg-eth2</a>
<a class="sourceLine" id="cb62-6" data-line-number="6"></a>
<a class="sourceLine" id="cb62-7" data-line-number="7"><span class="fu">xargs</span> 一次干掉</a>
<a class="sourceLine" id="cb62-8" data-line-number="8">    <span class="fu">rm</span> -f  ifcfg-eth0 ifcfg-eth1 ifcfg-eth2</a>
<a class="sourceLine" id="cb62-9" data-line-number="9"></a>
<a class="sourceLine" id="cb62-10" data-line-number="10"><span class="fu">touch</span> file-<span class="dt">{1..50000}</span></a>
<a class="sourceLine" id="cb62-11" data-line-number="11"><span class="co"># time find ./ -type f -name &quot;file-*&quot; -exec rm -f {} \;</span></a>
<a class="sourceLine" id="cb62-12" data-line-number="12"><span class="co"># time find ./ -type f -name &quot;file-*&quot; |xargs rm -f</span></a></code></pre></div>
<p>9.3 find逻辑运算符【-a -o ！】</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="co">#符号 作用</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"></a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="ex">-a</span> 与 and 默认写法不需加</a>
<a class="sourceLine" id="cb63-4" data-line-number="4"></a>
<a class="sourceLine" id="cb63-5" data-line-number="5"><span class="ex">-o</span> 或 or</a>
<a class="sourceLine" id="cb63-6" data-line-number="6"></a>
<a class="sourceLine" id="cb63-7" data-line-number="7">! 非 <span class="ex">-not</span></a></code></pre></div>
<h2 id="文件打包压缩">10.文件打包压缩</h2>
<p><strong>常见压缩包格式</strong></p>
<div class="sourceCode" id="cb64"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb64-1" data-line-number="1">格式              压缩工具</a>
<a class="sourceLine" id="cb64-2" data-line-number="2"><span class="ex">.zip</span>            zip压缩工具</a>
<a class="sourceLine" id="cb64-3" data-line-number="3"><span class="ex">.gz</span>             gzip压缩工具，只能压缩文件，会删除原文件(通常配合tar使用)</a>
<a class="sourceLine" id="cb64-4" data-line-number="4"><span class="ex">.bz2</span>            bzip2压缩工具，只能压缩文件，会删除原文件(通常配合tar使用)</a>
<a class="sourceLine" id="cb64-5" data-line-number="5"><span class="ex">.tar.gz</span>         先使用tar命令归档打包，然后使用gzip压缩</a>
<a class="sourceLine" id="cb64-6" data-line-number="6"><span class="ex">.tar.bz2</span>        先使用tar命令归档打包，然后使用bzip压缩</a></code></pre></div>
<h3 id="gzip.gz">10.1 gzip【.gz】</h3>
<p>使用gzip方式进行压缩文件 ( <strong>只能压缩文件，并且文件被压缩后，源文件没有了</strong>)</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="co">#参数</span></a>
<a class="sourceLine" id="cb65-2" data-line-number="2"><span class="ex">-d</span>          #解压gzip压缩包</a>
<a class="sourceLine" id="cb65-3" data-line-number="3"></a>
<a class="sourceLine" id="cb65-4" data-line-number="4"><span class="ex">yum</span> install gzip -y             #安装gzip压缩工具</a>
<a class="sourceLine" id="cb65-5" data-line-number="5"></a>
<a class="sourceLine" id="cb65-6" data-line-number="6"><span class="fu">gzip</span> file       #压缩文件</a>
<a class="sourceLine" id="cb65-7" data-line-number="7"><span class="fu">zcat</span> file.gz    #查看压缩文件</a>
<a class="sourceLine" id="cb65-8" data-line-number="8"><span class="fu">gzip</span> -d file.gz <span class="co">#解压压缩文件</span></a></code></pre></div>
<h3 id="gip.zip">10.2 gip【.zip】</h3>
<p><strong>zip, 使用zip命令可以对文件进行压缩打包，解压则需要使用unzip命令</strong></p>
<div class="sourceCode" id="cb66"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="ex">yum</span> install zip unzip -y</a>
<a class="sourceLine" id="cb66-2" data-line-number="2"></a>
<a class="sourceLine" id="cb66-3" data-line-number="3"><span class="co">#zip参数</span></a>
<a class="sourceLine" id="cb66-4" data-line-number="4"><span class="ex">-r</span>          #递归打包</a>
<a class="sourceLine" id="cb66-5" data-line-number="5"><span class="ex">-T</span>          #查看压缩包是否完整</a>
<a class="sourceLine" id="cb66-6" data-line-number="6"></a>
<a class="sourceLine" id="cb66-7" data-line-number="7"><span class="co">#unzip 参数</span></a>
<a class="sourceLine" id="cb66-8" data-line-number="8"><span class="ex">-l</span> / -t     #不解压查看压缩包内容</a>
<a class="sourceLine" id="cb66-9" data-line-number="9"><span class="ex">-d</span>          #指定解压目录</a>
<a class="sourceLine" id="cb66-10" data-line-number="10"></a>
<a class="sourceLine" id="cb66-11" data-line-number="11"><span class="fu">zip</span>  filename.zip  filename </a>
<a class="sourceLine" id="cb66-12" data-line-number="12"><span class="fu">zip</span> -r  dir.zip dir/</a>
<a class="sourceLine" id="cb66-13" data-line-number="13"><span class="fu">zip</span> -T  filename.zip</a>
<a class="sourceLine" id="cb66-14" data-line-number="14"></a>
<a class="sourceLine" id="cb66-15" data-line-number="15"><span class="co"># unzip -l  filename.zip</span></a>
<a class="sourceLine" id="cb66-16" data-line-number="16"><span class="co"># unzip -t  filename.zip</span></a>
<a class="sourceLine" id="cb66-17" data-line-number="17"><span class="co"># unzip  filename.zip</span></a>
<a class="sourceLine" id="cb66-18" data-line-number="18"><span class="co"># unzip filename.zip  -d /opt/</span></a></code></pre></div>
<h3 id="tar.tar.gz.tar.bz2">10.3 tar【.tar.gz|.tar.bz2】</h3>
<p><strong>tar是linux下最常用的压缩与解压缩, 支持文件和目录的压缩归档</strong></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="ex">c</span>   #创建新的归档文件</a>
<a class="sourceLine" id="cb67-2" data-line-number="2"><span class="ex">x</span>   #对归档文件解包</a>
<a class="sourceLine" id="cb67-3" data-line-number="3"><span class="ex">t</span>   #列出归档文件里的文件列表</a>
<a class="sourceLine" id="cb67-4" data-line-number="4"><span class="ex">v</span>   #输出命令的归档或解包的过程</a>
<a class="sourceLine" id="cb67-5" data-line-number="5"><span class="ex">f</span>   #指定包文件名，多参数f写最后</a>
<a class="sourceLine" id="cb67-6" data-line-number="6"></a>
<a class="sourceLine" id="cb67-7" data-line-number="7"><span class="ex">z</span>   #使用gzip压缩归档后的文件(.tar.gz)</a>
<a class="sourceLine" id="cb67-8" data-line-number="8"><span class="ex">j</span>   #使用bzip2压缩归档后的文件(.tar.bz2)</a>
<a class="sourceLine" id="cb67-9" data-line-number="9"><span class="ex">J</span>   #使用xz压缩归档后的文件(tar.xz)</a>
<a class="sourceLine" id="cb67-10" data-line-number="10"><span class="ex">C</span>   #指定解压目录位置</a>
<a class="sourceLine" id="cb67-11" data-line-number="11"><span class="ex">X</span>   #排除多个文件(写入需要排除的文件名称)</a>
<a class="sourceLine" id="cb67-12" data-line-number="12"><span class="ex">h</span>   #打包软链接</a>
<a class="sourceLine" id="cb67-13" data-line-number="13"><span class="ex">--exclude</span>   #在打包的时候写入需要排除文件或目录</a></code></pre></div>
<h3 id="常用打包与压缩组合">常用打包与压缩组合</h3>
<div class="sourceCode" id="cb68"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="ex">czf</span>     #打包tar.gz格式</a>
<a class="sourceLine" id="cb68-2" data-line-number="2"><span class="ex">cjf</span>     #打包tar.bz格式</a>
<a class="sourceLine" id="cb68-3" data-line-number="3"><span class="ex">cJf</span>     #打包tar.xz格式</a>
<a class="sourceLine" id="cb68-4" data-line-number="4"></a>
<a class="sourceLine" id="cb68-5" data-line-number="5"><span class="ex">zxf</span>     #解压tar.gz格式</a>
<a class="sourceLine" id="cb68-6" data-line-number="6"><span class="ex">jxf</span>     #解压tar.bz格式</a>
<a class="sourceLine" id="cb68-7" data-line-number="7"><span class="ex">xf</span>      #自动选择解压模式   常用写法自动选择解压</a>
<a class="sourceLine" id="cb68-8" data-line-number="8"><span class="ex">tf</span>      #查看压缩包内容</a></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="co">#1.以gzip归档方式打包并压缩</span></a>
<a class="sourceLine" id="cb69-2" data-line-number="2"><span class="fu">tar</span> czf  test.tar.gz  test/ test2/</a>
<a class="sourceLine" id="cb69-3" data-line-number="3"></a>
<a class="sourceLine" id="cb69-4" data-line-number="4"><span class="co">#2.以bz2方式压缩</span></a>
<a class="sourceLine" id="cb69-5" data-line-number="5"><span class="ex">yum</span> install bzip2 -y</a>
<a class="sourceLine" id="cb69-6" data-line-number="6"><span class="fu">tar</span> cjf  test.tar.bz2 dir.txt dir/</a>
<a class="sourceLine" id="cb69-7" data-line-number="7"></a>
<a class="sourceLine" id="cb69-8" data-line-number="8"><span class="co">#3.打包链接文件,打包链接文件的真实文件[加参数-h]</span></a>
<a class="sourceLine" id="cb69-9" data-line-number="9"><span class="bu">cd</span> /</a>
<a class="sourceLine" id="cb69-10" data-line-number="10">[<span class="ex">root@</span> /]# tar czfh local.tar.gz  etc/rc.local</a>
<a class="sourceLine" id="cb69-11" data-line-number="11"></a>
<a class="sourceLine" id="cb69-12" data-line-number="12"><span class="co">#4.打包/tmp下所有文件</span></a>
<a class="sourceLine" id="cb69-13" data-line-number="13"><span class="bu">cd</span> /</a>
<a class="sourceLine" id="cb69-14" data-line-number="14">[<span class="ex">root@</span> /]# find tmp/ -type f <span class="kw">|</span> <span class="fu">xargs</span> tar czf tmp.tar.gz</a>
<a class="sourceLine" id="cb69-15" data-line-number="15"></a>
<a class="sourceLine" id="cb69-16" data-line-number="16">方法二:</a>
<a class="sourceLine" id="cb69-17" data-line-number="17">[<span class="ex">root@</span> /]# tar czf tmp2.tar.gz <span class="va">$(</span><span class="fu">find</span> /tmp/ -type f<span class="va">)</span>    #会优先执行<span class="va">$()</span>里的内容并作为参数传递</a></code></pre></div>
<p>总结</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="fu">tar</span> </a>
<a class="sourceLine" id="cb70-2" data-line-number="2">    <span class="ex">czf</span> <span class="co">#tar.gz    </span></a>
<a class="sourceLine" id="cb70-3" data-line-number="3">    <span class="ex">cjf</span> <span class="co">#tar.bz2</span></a>
<a class="sourceLine" id="cb70-4" data-line-number="4"><span class="fu">tar</span></a>
<a class="sourceLine" id="cb70-5" data-line-number="5">    <span class="ex">tf</span>  浏览包内容</a>
<a class="sourceLine" id="cb70-6" data-line-number="6"></a>
<a class="sourceLine" id="cb70-7" data-line-number="7"><span class="fu">tar</span></a>
<a class="sourceLine" id="cb70-8" data-line-number="8">    <span class="ex">xf</span>  智能解压</a>
<a class="sourceLine" id="cb70-9" data-line-number="9">    <span class="fu">tar</span>  xf xx.tar.gz -C /opt   #-C 指定解压到opt目录</a>
<a class="sourceLine" id="cb70-10" data-line-number="10"></a>
<a class="sourceLine" id="cb70-11" data-line-number="11"></a>
<a class="sourceLine" id="cb70-12" data-line-number="12">打包一个<span class="ex">tar.gz</span>的压缩包，压缩/etc /opt /tmp  ,检查压缩包的中内容，最后解压到当前目录。</a>
<a class="sourceLine" id="cb70-13" data-line-number="13"> <span class="fu">tar</span> czf eot.tar.gz /etc/ /opt/ /tmp/</a>
<a class="sourceLine" id="cb70-14" data-line-number="14"> <span class="fu">tar</span> tf eot.tar.gz</a>
<a class="sourceLine" id="cb70-15" data-line-number="15"> <span class="fu">tar</span> xf eot.tar.gz</a></code></pre></div>
<h3 id="exclude-排除打包文件">10.4 –exclude 排除打包文件</h3>
<div class="sourceCode" id="cb71"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="co">#排除单个文件</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"> <span class="fu">tar</span> czf etc.tar.gz --exclude=etc/services etc/</a>
<a class="sourceLine" id="cb71-3" data-line-number="3"> </a>
<a class="sourceLine" id="cb71-4" data-line-number="4">将需要排除的文件写入文件中</a>
<a class="sourceLine" id="cb71-5" data-line-number="5">[<span class="ex">root@</span> opt]# cat ~/pc.txt</a>
<a class="sourceLine" id="cb71-6" data-line-number="6"><span class="ex">etc/sysconfig/network-scripts/ifcfg-eth0</span></a>
<a class="sourceLine" id="cb71-7" data-line-number="7"><span class="ex">etc/services</span></a>
<a class="sourceLine" id="cb71-8" data-line-number="8"><span class="ex">etc/rc.local</span></a>
<a class="sourceLine" id="cb71-9" data-line-number="9"></a>
<a class="sourceLine" id="cb71-10" data-line-number="10"><span class="co">#指定需要排除的文件列表, 最后进行打包压缩</span></a>
<a class="sourceLine" id="cb71-11" data-line-number="11">语法:<span class="ex">tar</span> 参数 压缩包名称 要排除的文件 打包的内容</a>
<a class="sourceLine" id="cb71-12" data-line-number="12">[<span class="ex">root@</span> ~]# tar czfX oo3.tar.gz  pc.txt  /etc/</a>
<a class="sourceLine" id="cb71-13" data-line-number="13"><span class="ex">tar</span>: 从成员名中删除开头的“/”</a>
<a class="sourceLine" id="cb71-14" data-line-number="14"><span class="co">#由于打包时使用的是全路径，默认系统会把开头的/删除，但是我们在解压时 指定解压到 / 下面</span></a>
<a class="sourceLine" id="cb71-15" data-line-number="15">[<span class="ex">root@db01-172</span> ~]# cp oo3.tar.gz  /opt/</a>
<a class="sourceLine" id="cb71-16" data-line-number="16">[<span class="ex">root@db01-172</span> ~]# cd /opt/</a>
<a class="sourceLine" id="cb71-17" data-line-number="17">[<span class="ex">root@db01-172</span> opt]# tar xf oo3.tar.gz</a>
<a class="sourceLine" id="cb71-18" data-line-number="18">[<span class="ex">root@db01-172</span> opt]# find etc/ -type f <span class="kw">|</span><span class="fu">grep</span> <span class="st">&quot;ifcg*&quot;</span></a>
<a class="sourceLine" id="cb71-19" data-line-number="19"><span class="ex">etc/sysconfig/network-scripts/ifcfg-lo</span></a>
<a class="sourceLine" id="cb71-20" data-line-number="20">[<span class="ex">root@db01-172</span> opt]# find etc/ -type f <span class="kw">|</span><span class="fu">grep</span> <span class="st">&quot;services&quot;</span></a>
<a class="sourceLine" id="cb71-21" data-line-number="21">[<span class="ex">root@db01-172</span> opt]# find etc/ -type f <span class="kw">|</span><span class="fu">grep</span> <span class="st">&quot;rc.local&quot;</span></a>
<a class="sourceLine" id="cb71-22" data-line-number="22"><span class="ex">etc/rc.d/rc.local</span></a></code></pre></div>
<h2 id="rpm包管理">11. rpm包管理</h2>
<p><strong>rpm软件包的组成部分有哪些？</strong></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="ex">bash-doc-4.2.46-34.el7.x86_64.rpm</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2"></a>
<a class="sourceLine" id="cb72-3" data-line-number="3"><span class="ex">bash-doc</span>：包名称</a>
<a class="sourceLine" id="cb72-4" data-line-number="4"><span class="ex">4.2.46</span>：版本号</a>
<a class="sourceLine" id="cb72-5" data-line-number="5"><span class="ex">-34</span>：发布次数</a>
<a class="sourceLine" id="cb72-6" data-line-number="6"><span class="ex">el7</span>：表示软件包可以在 Red Hat 7.x，CentOS 7.x，CloudLinux 7.x 进行安装</a>
<a class="sourceLine" id="cb72-7" data-line-number="7"><span class="ex">.x86_64</span>：硬件平台https://blog.csdn.net/sunny_day_day/article/details/108714946</a>
<a class="sourceLine" id="cb72-8" data-line-number="8"><span class="ex">.rpm</span>:扩展名</a></code></pre></div>
<p><strong>使用rpm工具安装rpm包</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">-i</td>
<td style="text-align: left;">安装rpm</td>
</tr>
<tr class="even">
<td style="text-align: left;">-v</td>
<td style="text-align: left;">显示安装详细信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-h</td>
<td style="text-align: left;">显示安装rpm进度</td>
</tr>
<tr class="even">
<td style="text-align: left;">–force</td>
<td style="text-align: left;">强制重新安装</td>
</tr>
<tr class="odd">
<td style="text-align: left;">–nodeps</td>
<td style="text-align: left;">忽略依赖关系</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb73"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="co">#参数 </span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2"><span class="ex">-ivh</span>        安装npm包</a>
<a class="sourceLine" id="cb73-3" data-line-number="3"><span class="ex">-iUh</span>        升级安装的npm包</a>
<a class="sourceLine" id="cb73-4" data-line-number="4"><span class="ex">-e</span>          卸载软件</a>
<a class="sourceLine" id="cb73-5" data-line-number="5"></a>
<a class="sourceLine" id="cb73-6" data-line-number="6"><span class="ex">rpm</span> -q      查看指定软件包是否安装</a>
<a class="sourceLine" id="cb73-7" data-line-number="7"><span class="ex">rpm</span> -qa     查看系统中已安装的所有RPM软件包列表</a>
<a class="sourceLine" id="cb73-8" data-line-number="8"><span class="ex">rpm</span> -qi     查看指定软件的详细信息</a>
<a class="sourceLine" id="cb73-9" data-line-number="9"><span class="ex">rpm</span> -ql     查询指定软件包所安装的目录、文件列表</a>
<a class="sourceLine" id="cb73-10" data-line-number="10"><span class="ex">rpm</span> -qc     查询指定软件包的配置文件</a>
<a class="sourceLine" id="cb73-11" data-line-number="11"><span class="ex">rpm</span> -qf     查询文件或目录属于哪个RPM软件</a>
<a class="sourceLine" id="cb73-12" data-line-number="12"><span class="ex">rpm</span> -qip    查询未安装的rpm包详细信息</a>
<a class="sourceLine" id="cb73-13" data-line-number="13"><span class="ex">rpm</span> -qlp    查询未安装的软件包会产生哪些文件</a></code></pre></div>
<h2 id="yum包管理">12. yum包管理</h2>
<div class="sourceCode" id="cb74"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb74-1" data-line-number="1"><span class="ex">yum</span> localinstall        #安装本地rpm包会自动解决依赖</a>
<a class="sourceLine" id="cb74-2" data-line-number="2"></a>
<a class="sourceLine" id="cb74-3" data-line-number="3"><span class="ex">yum</span> install         安装</a>
<a class="sourceLine" id="cb74-4" data-line-number="4"><span class="ex">yum</span> reinstall       重装</a>
<a class="sourceLine" id="cb74-5" data-line-number="5"><span class="ex">yum</span> update          更新</a>
<a class="sourceLine" id="cb74-6" data-line-number="6"><span class="ex">yum</span> remove          删除</a>
<a class="sourceLine" id="cb74-7" data-line-number="7"><span class="ex">yum</span> repolist        查看仓库总和的rpm包</a>
<a class="sourceLine" id="cb74-8" data-line-number="8"><span class="ex">yum</span> repolist all    查看所有的仓库 （ 包括启用和禁用 ）</a>
<a class="sourceLine" id="cb74-9" data-line-number="9"><span class="ex">yum</span> provides        查询命令是 哪个仓库下的哪个软件包提供</a>
<a class="sourceLine" id="cb74-10" data-line-number="10"><span class="ex">yum</span> groups install  安装组包</a>
<a class="sourceLine" id="cb74-11" data-line-number="11"><span class="ex">yum</span> groups remove   移除组包</a>
<a class="sourceLine" id="cb74-12" data-line-number="12"><span class="ex">yum</span> history </a>
<a class="sourceLine" id="cb74-13" data-line-number="13"><span class="ex">yum</span> history info</a>
<a class="sourceLine" id="cb74-14" data-line-number="14"><span class="ex">yum</span> history undo </a>
<a class="sourceLine" id="cb74-15" data-line-number="15"><span class="ex">yum</span> clean all       清理所有的缓存</a>
<a class="sourceLine" id="cb74-16" data-line-number="16"><span class="ex">yum</span> clean packages  清理所有已缓存的rpm包</a>
<a class="sourceLine" id="cb74-17" data-line-number="17"></a>
<a class="sourceLine" id="cb74-18" data-line-number="18"><span class="co">#更新缓存</span></a>
<a class="sourceLine" id="cb74-19" data-line-number="19"><span class="ex">yum</span> clean all</a>
<a class="sourceLine" id="cb74-20" data-line-number="20"><span class="ex">yum</span> makecache</a></code></pre></div>
<h2 id="磁盘管理">13. 磁盘管理</h2>
<h3 id="fdisk-磁盘分区">13.1、fdisk 磁盘分区</h3>
<p><strong>fdisk只能划分小于2TB的磁盘，所以要添加一块小于2TB的硬盘</strong></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb75-1" data-line-number="1">输入<span class="ex">m</span>进入帮助显示信息如下：</a>
<a class="sourceLine" id="cb75-2" data-line-number="2">[<span class="ex">root@web01</span> ~]# fdisk -l</a>
<a class="sourceLine" id="cb75-3" data-line-number="3">[<span class="ex">root@web01</span> ~]# fdisk  /dev/sdb</a>
<a class="sourceLine" id="cb75-4" data-line-number="4"><span class="ex">Command</span> (m for help)<span class="bu">:</span> m         #输入m列出常用的命令</a>
<a class="sourceLine" id="cb75-5" data-line-number="5"><span class="ex">Command</span> action</a>
<a class="sourceLine" id="cb75-6" data-line-number="6">   <span class="ex">a</span>   toggle a bootable flag               #切换分区启动标记</a>
<a class="sourceLine" id="cb75-7" data-line-number="7">   <span class="ex">b</span>   edit bsd disklabel                   #编辑sdb磁盘标签</a>
<a class="sourceLine" id="cb75-8" data-line-number="8">   <span class="ex">c</span>   toggle the dos compatibility flag    #切换dos兼容模式</a>
<a class="sourceLine" id="cb75-9" data-line-number="9">   <span class="ex">d</span>   delete a partition                   #删除分区</a>
<a class="sourceLine" id="cb75-10" data-line-number="10">   <span class="ex">l</span>   list known partition types           #显示分区类型</a>
<a class="sourceLine" id="cb75-11" data-line-number="11">   <span class="ex">m</span>   print this menu                      #显示帮助菜单</a>
<a class="sourceLine" id="cb75-12" data-line-number="12">   <span class="ex">n</span>   add a new partition                  #新建分区</a>
<a class="sourceLine" id="cb75-13" data-line-number="13">   <span class="ex">o</span>   create a new empty DOS partition table   #创建新的空白分区表</a>
<a class="sourceLine" id="cb75-14" data-line-number="14">   <span class="ex">p</span>   print the partition table            #显示分区表的信息</a>
<a class="sourceLine" id="cb75-15" data-line-number="15">   <span class="ex">q</span>   quit without saving changes          #不保存退出</a>
<a class="sourceLine" id="cb75-16" data-line-number="16">   <span class="ex">s</span>   create a new empty Sun disklabel     #创建新的Sun磁盘标签</a>
<a class="sourceLine" id="cb75-17" data-line-number="17">   <span class="ex">t</span>   change a partitions system id        #修改分区ID,可以通过l查看id</a>
<a class="sourceLine" id="cb75-18" data-line-number="18">   <span class="ex">u</span>   change display/entry units           #修改容量单位,磁柱或扇区</a>
<a class="sourceLine" id="cb75-19" data-line-number="19">   <span class="ex">v</span>   verify the partition table           #检验分区表</a>
<a class="sourceLine" id="cb75-20" data-line-number="20">   <span class="fu">w</span>   write table to disk and exit         #保存退出</a>
<a class="sourceLine" id="cb75-21" data-line-number="21">   <span class="ex">x</span>   extra functionality (experts only)   #拓展功能</a>
<a class="sourceLine" id="cb75-22" data-line-number="22"></a>
<a class="sourceLine" id="cb75-23" data-line-number="23"><span class="co">#1.fdisk创建主分区</span></a>
<a class="sourceLine" id="cb75-24" data-line-number="24"><span class="ex">Command</span> (m for help)<span class="bu">:</span> n</a>
<a class="sourceLine" id="cb75-25" data-line-number="25"><span class="ex">Partition</span> type:</a>
<a class="sourceLine" id="cb75-26" data-line-number="26">   <span class="ex">p</span>   primary (0 primary, 0 extended, 4 free)  #主分区</a>
<a class="sourceLine" id="cb75-27" data-line-number="27">   <span class="ex">e</span>   extended  #扩展分区</a>
<a class="sourceLine" id="cb75-28" data-line-number="28"><span class="ex">Select</span> (default p)<span class="bu">:</span> p   #选择创建主分区</a>
<a class="sourceLine" id="cb75-29" data-line-number="29"><span class="ex">Partition</span> number (1-4, default 1)<span class="bu">:</span>  #默认创建第一个主分区</a>
<a class="sourceLine" id="cb75-30" data-line-number="30"><span class="ex">First</span> sector (2048-2097151, default 2048)<span class="bu">:</span> <span class="co">#默认扇区回车</span></a>
<a class="sourceLine" id="cb75-31" data-line-number="31"><span class="ex">Using</span> default value 2048</a>
<a class="sourceLine" id="cb75-32" data-line-number="32"><span class="ex">Last</span> sector, +sectors or +size<span class="dt">{K,M,G}</span> (2048-2097151, default 2097151)<span class="bu">:</span> +50M <span class="co">#分配空间50MB</span></a>
<a class="sourceLine" id="cb75-33" data-line-number="33"></a>
<a class="sourceLine" id="cb75-34" data-line-number="34"></a>
<a class="sourceLine" id="cb75-35" data-line-number="35"><span class="co">#2.fdisk创建扩展分区</span></a>
<a class="sourceLine" id="cb75-36" data-line-number="36"><span class="ex">Command</span> (m for help)<span class="bu">:</span> n  #新建分区</a>
<a class="sourceLine" id="cb75-37" data-line-number="37"><span class="ex">Partition</span> type:</a>
<a class="sourceLine" id="cb75-38" data-line-number="38">   <span class="ex">p</span>   primary (1 primary, 0 extended, 3 free)</a>
<a class="sourceLine" id="cb75-39" data-line-number="39">   <span class="ex">e</span>   extended</a>
<a class="sourceLine" id="cb75-40" data-line-number="40"><span class="ex">Select</span> (default p)<span class="bu">:</span> e   #创建扩展分区</a>
<a class="sourceLine" id="cb75-41" data-line-number="41"><span class="ex">Partition</span> number (2-4, default 2)<span class="bu">:</span></a>
<a class="sourceLine" id="cb75-42" data-line-number="42"><span class="ex">First</span> sector (104448-2097151, default 104448)<span class="bu">:</span></a>
<a class="sourceLine" id="cb75-43" data-line-number="43"><span class="ex">Using</span> default value 104448</a>
<a class="sourceLine" id="cb75-44" data-line-number="44"><span class="ex">Last</span> sector, +sectors or +size<span class="dt">{K,M,G}</span> (104448-2097151, default 2097151)<span class="bu">:</span> <span class="co">#空间都给到扩展分区</span></a>
<a class="sourceLine" id="cb75-45" data-line-number="45"></a>
<a class="sourceLine" id="cb75-46" data-line-number="46"><span class="co">#3.fdisk创建逻辑分区</span></a>
<a class="sourceLine" id="cb75-47" data-line-number="47"><span class="ex">Command</span> (m for help)<span class="bu">:</span> n  #新建分区</a>
<a class="sourceLine" id="cb75-48" data-line-number="48"><span class="ex">Partition</span> type:</a>
<a class="sourceLine" id="cb75-49" data-line-number="49">   <span class="ex">p</span>   primary (1 primary, 1 extended, 2 free)</a>
<a class="sourceLine" id="cb75-50" data-line-number="50">   <span class="ex">l</span>   logical (numbered from 5)</a>
<a class="sourceLine" id="cb75-51" data-line-number="51"><span class="ex">Select</span> (default p)<span class="bu">:</span> l   #创建逻辑分区</a>
<a class="sourceLine" id="cb75-52" data-line-number="52"><span class="ex">Adding</span> logical partition 5</a>
<a class="sourceLine" id="cb75-53" data-line-number="53"><span class="ex">First</span> sector (106496-2097151, default 106496)<span class="bu">:</span></a>
<a class="sourceLine" id="cb75-54" data-line-number="54"><span class="ex">Using</span> default value 106496</a>
<a class="sourceLine" id="cb75-55" data-line-number="55"><span class="ex">Last</span> sector, +sectors or +size<span class="dt">{K,M,G}</span> (106496-2097151, default 2097151)<span class="bu">:</span> +100M  #分配100MB空间</a>
<a class="sourceLine" id="cb75-56" data-line-number="56"></a>
<a class="sourceLine" id="cb75-57" data-line-number="57"><span class="co">#4.fdisk查看分区情况，并保存</span></a>
<a class="sourceLine" id="cb75-58" data-line-number="58"><span class="ex">Command</span> (m for help)<span class="bu">:</span> p <span class="co">#查看分区创建</span></a>
<a class="sourceLine" id="cb75-59" data-line-number="59"><span class="ex">Device</span> Boot      Start         End      Blocks   Id  System</a>
<a class="sourceLine" id="cb75-60" data-line-number="60"><span class="ex">/dev/sdb1</span>            2048      104447       51200   83  Linux</a>
<a class="sourceLine" id="cb75-61" data-line-number="61"><span class="ex">/dev/sdb2</span>          104448     2097151      996352    5  Extended</a>
<a class="sourceLine" id="cb75-62" data-line-number="62"><span class="ex">/dev/sdb5</span>          106496      311295      102400   83  Linux</a>
<a class="sourceLine" id="cb75-63" data-line-number="63"></a>
<a class="sourceLine" id="cb75-64" data-line-number="64"><span class="co">#保存分区</span></a>
<a class="sourceLine" id="cb75-65" data-line-number="65"><span class="ex">Command</span> (m for help)<span class="bu">:</span> w</a>
<a class="sourceLine" id="cb75-66" data-line-number="66"><span class="ex">The</span> partition table has been altered!</a>
<a class="sourceLine" id="cb75-67" data-line-number="67"><span class="ex">Calling</span> ioctl() <span class="ex">to</span> re-read partition table.</a>
<a class="sourceLine" id="cb75-68" data-line-number="68"><span class="ex">Syncing</span> disks.</a></code></pre></div>
<p>小坑：分区失败删除了,系统为生效,可以安装partprobe指令刷新内核创建完成后，可以尝试检查磁盘是否为gpt格式</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb76-1" data-line-number="1">[<span class="ex">root@xuliangwei-node1</span> /]# fdisk /dev/sdb -l<span class="kw">|</span><span class="fu">grep</span> type</a>
<a class="sourceLine" id="cb76-2" data-line-number="2"><span class="ex">Disk</span> label type: gpt</a>
<a class="sourceLine" id="cb76-3" data-line-number="3"></a>
<a class="sourceLine" id="cb76-4" data-line-number="4">安装<span class="ex">parted</span>, 刷新内核立即生效,无需重启</a>
<a class="sourceLine" id="cb76-5" data-line-number="5">[<span class="ex">root@</span> ~]# yum -y install parted</a>
<a class="sourceLine" id="cb76-6" data-line-number="6">[<span class="ex">root@</span> ~]# partprobe</a></code></pre></div>
<h3 id="mkfs-格式分区">13.2、mkfs 格式分区</h3>
<p><strong>mkfs格式化磁盘，实质创建文件系统，文件系统类似于将房子装修成3室一厅，还是2室一厅。</strong></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb77-1" data-line-number="1"><span class="co">#选项: </span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2"><span class="co"># -b  设定数据区块占用空间大小，目前支持1024、2048、4096 bytes每个块。</span></a>
<a class="sourceLine" id="cb77-3" data-line-number="3"><span class="co"># -t  用来指定什么类型的文件系统，可以是ext4, xfs</span></a>
<a class="sourceLine" id="cb77-4" data-line-number="4"><span class="co"># -i  设定inode的大小</span></a>
<a class="sourceLine" id="cb77-5" data-line-number="5"><span class="co"># -N  设定inode数量，防止Inode数量不够导致磁盘不足</span></a>
<a class="sourceLine" id="cb77-6" data-line-number="6"></a>
<a class="sourceLine" id="cb77-7" data-line-number="7"><span class="co">#1.格式化整个磁盘</span></a>
<a class="sourceLine" id="cb77-8" data-line-number="8">[<span class="ex">root@xuliangwei</span> ~]# mkfs.ext4  /dev/sdb </a>
<a class="sourceLine" id="cb77-9" data-line-number="9"></a>
<a class="sourceLine" id="cb77-10" data-line-number="10"><span class="co">#2.格式化磁盘的某个分区</span></a>
<a class="sourceLine" id="cb77-11" data-line-number="11">[<span class="ex">root@xuliangwei</span> ~]# mkfs.xfs  /dev/sdb1</a></code></pre></div>
<h3 id="mount-挂载">13.3、mount 挂载</h3>
<p>如果需要使用该磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。</p>
<p><strong>1.临时挂载</strong></p>
<div class="sourceCode" id="cb78"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb78-1" data-line-number="1"><span class="co"># 选项：-t指定文件系统挂载分区 -a 挂载/etc/fstab中的配置文件 -o 指定挂载参数</span></a>
<a class="sourceLine" id="cb78-2" data-line-number="2"><span class="co"># 挂载/dev/sdb1至db1目录</span></a>
<a class="sourceLine" id="cb78-3" data-line-number="3">[<span class="ex">root@</span> ~]# mkdir /db1</a>
<a class="sourceLine" id="cb78-4" data-line-number="4">[<span class="ex">root@</span> ~]# mount -t xfs /dev/sdb1  /db1/ </a></code></pre></div>
<p><strong>2.umount卸载</strong></p>
<p>挂载的磁盘，如果不想使用可以使用umount进行卸载。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="co">#选项：</span></a>
<a class="sourceLine" id="cb79-2" data-line-number="2"><span class="ex">-l</span> 强制卸载</a>
<a class="sourceLine" id="cb79-3" data-line-number="3"><span class="ex">-o</span> 指定挂载参数，默认是读写rw，只读or</a>
<a class="sourceLine" id="cb79-4" data-line-number="4"><span class="fu">mount</span> -o or /dev/sdc1 /data-c/            </a>
<a class="sourceLine" id="cb79-5" data-line-number="5"></a>
<a class="sourceLine" id="cb79-6" data-line-number="6"><span class="co">#1.卸载目录方式</span></a>
<a class="sourceLine" id="cb79-7" data-line-number="7">[<span class="ex">root@</span> ~]# umount /db1</a>
<a class="sourceLine" id="cb79-8" data-line-number="8"></a>
<a class="sourceLine" id="cb79-9" data-line-number="9"><span class="co">#2.卸载设备方式</span></a>
<a class="sourceLine" id="cb79-10" data-line-number="10">[<span class="ex">root@</span> ~]# umount /dev/sdb1</a>
<a class="sourceLine" id="cb79-11" data-line-number="11"></a>
<a class="sourceLine" id="cb79-12" data-line-number="12"><span class="co">#3.umount不能卸载的情况</span></a>
<a class="sourceLine" id="cb79-13" data-line-number="13">[<span class="ex">root@</span> db1]# umount /db1  </a>
<a class="sourceLine" id="cb79-14" data-line-number="14"><span class="ex">umount</span>: /db1: device is busy.</a>
<a class="sourceLine" id="cb79-15" data-line-number="15">        <span class="kw">(</span><span class="ex">In</span> some cases useful info about processes that use</a>
<a class="sourceLine" id="cb79-16" data-line-number="16">         <span class="ex">the</span> device is found by lsof(8<span class="kw">)</span> <span class="ex">or</span> fuser(1)</a>
<a class="sourceLine" id="cb79-17" data-line-number="17"></a>
<a class="sourceLine" id="cb79-18" data-line-number="18"><span class="co">#PS: 如上情况解决办法有两种, 1.切换至其他目录 2.使用&#39;-l&#39;选项强制卸载    </span></a>
<a class="sourceLine" id="cb79-19" data-line-number="19">[<span class="ex">root@student</span> db1]# umount -l /db1</a></code></pre></div>
<p><strong>2.永久挂载</strong></p>
<p>永久生效，就需要配置一个文件 /etc/fstab （开机会加载该文件中的设备）</p>
<p><strong>/etc/fstab配置文件编写格式</strong></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb80-1" data-line-number="1">要挂载的设备  挂载点<span class="kw">(</span>入口<span class="kw">)</span> 文件系统类型  挂载参数        是否备份    是否检查</a>
<a class="sourceLine" id="cb80-2" data-line-number="2"><span class="ex">/dev/sdb1</span>   /db1          xfs       defaults        0           0</a>
<a class="sourceLine" id="cb80-3" data-line-number="3"></a>
<a class="sourceLine" id="cb80-4" data-line-number="4"><span class="co">#第一列：可以使用UUID也可以使用设备名称</span></a>
<a class="sourceLine" id="cb80-5" data-line-number="5">[<span class="ex">root@container</span> ~]# blkid                                   #查看磁盘的UUID</a>
<a class="sourceLine" id="cb80-6" data-line-number="6"><span class="ex">/dev</span>/sda1: <span class="va">UUID=</span><span class="st">&quot;723eb45d-9a1b-4e8f-b06d-cf9024302147&quot;</span> <span class="va">TYPE=</span><span class="st">&quot;xfs&quot;</span></a>
<a class="sourceLine" id="cb80-7" data-line-number="7"><span class="ex">/dev</span>/sda2: <span class="va">UUID=</span><span class="st">&quot;yVHSU3-Cmkf-qsg9-6DNg-P87L-mCDN-VOHvcO&quot;</span> <span class="va">TYPE=</span><span class="st">&quot;LVM2_member&quot;</span></a>
<a class="sourceLine" id="cb80-8" data-line-number="8"><span class="ex">/dev</span>/sdb1: <span class="va">UUID=</span><span class="st">&quot;3b0143a3-39af-4991-afab-01227fbe767c&quot;</span> <span class="va">TYPE=</span><span class="st">&quot;xfs&quot;</span></a>
<a class="sourceLine" id="cb80-9" data-line-number="9"></a>
<a class="sourceLine" id="cb80-10" data-line-number="10"><span class="co">#第四列：挂载参数。挂载参数有很多，在这块我们了解即可，不必深究。【一般使用default】</span></a>
<a class="sourceLine" id="cb80-11" data-line-number="11">参数          含义</a>
<a class="sourceLine" id="cb80-12" data-line-number="12"><span class="ex">async/sync</span>  是否为同步方式运行。默认async</a>
<a class="sourceLine" id="cb80-13" data-line-number="13"><span class="ex">user/nouser</span> 是否允许普通用户使用mount命令挂载。默认nouser</a>
<a class="sourceLine" id="cb80-14" data-line-number="14"><span class="ex">exec/noexe</span>  是否允许可执行文件执行。默认exec</a>
<a class="sourceLine" id="cb80-15" data-line-number="15"><span class="ex">suid/nosuid</span> 是否允许存在suid属性的文件。默认suid</a>
<a class="sourceLine" id="cb80-16" data-line-number="16"><span class="ex">auto/noauto</span> 执行mount -a 命令时，此文件系统是否被主动挂载。默认auto</a>
<a class="sourceLine" id="cb80-17" data-line-number="17"><span class="ex">rw/ro</span>       是否以只读或者读写模式进行挂载。默认rw</a>
<a class="sourceLine" id="cb80-18" data-line-number="18"><span class="ex">default</span>     具有rw,suid,dev,exec,auto,nouser,async等默认参数的设定。</a>
<a class="sourceLine" id="cb80-19" data-line-number="19"></a>
<a class="sourceLine" id="cb80-20" data-line-number="20"><span class="co">#第五列：是否进行备份。通常这个参数的值为0或者1               【不备份】</span></a>
<a class="sourceLine" id="cb80-21" data-line-number="21">选项  含义</a>
<a class="sourceLine" id="cb80-22" data-line-number="22"><span class="ex">0</span>   代表不做备份</a>
<a class="sourceLine" id="cb80-23" data-line-number="23"><span class="ex">1</span>   代表要每天进行备份操作</a>
<a class="sourceLine" id="cb80-24" data-line-number="24"><span class="ex">2</span>   代表不定日期的进行备份操作</a>
<a class="sourceLine" id="cb80-25" data-line-number="25"></a>
<a class="sourceLine" id="cb80-26" data-line-number="26"><span class="co">#第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整    【不检查】</span></a>
<a class="sourceLine" id="cb80-27" data-line-number="27">选项  含义</a>
<a class="sourceLine" id="cb80-28" data-line-number="28"><span class="ex">0</span>   不要检验磁盘是否有坏道</a>
<a class="sourceLine" id="cb80-29" data-line-number="29"><span class="ex">1</span>   检验</a>
<a class="sourceLine" id="cb80-30" data-line-number="30"><span class="ex">2</span>   校验 (当1级别检验完成之后进行2级别检验)</a>
<a class="sourceLine" id="cb80-31" data-line-number="31"></a>
<a class="sourceLine" id="cb80-32" data-line-number="32"></a>
<a class="sourceLine" id="cb80-33" data-line-number="33"><span class="co">#示例：</span></a>
<a class="sourceLine" id="cb80-34" data-line-number="34">[<span class="ex">root@container</span> ~]# tail  /etc/fstab           #进入开机加载文件添加一个挂载</a>
<a class="sourceLine" id="cb80-35" data-line-number="35"><span class="ex">/dev/sdb1</span>   /data1      xfs defaults 0 0</a></code></pre></div>
<p><strong>如何知道写的对于不对 mount -a ( 会去加载/etc/fstab中的 挂载信息 )</strong></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb81-1" data-line-number="1">[<span class="ex">root@container</span> ~]# mount -a</a>
<a class="sourceLine" id="cb81-2" data-line-number="2"></a>
<a class="sourceLine" id="cb81-3" data-line-number="3">[<span class="ex">root@container</span> ~]# df -h               #检查挂载点</a>
<a class="sourceLine" id="cb81-4" data-line-number="4">文件系统                 容量  已用  可用 已用<span class="ex">%</span> 挂载点</a>
<a class="sourceLine" id="cb81-5" data-line-number="5"><span class="ex">/dev/sdb1</span>               20G   33M  20G  1% /data1       《--读取/etc/fstab 加载该设备</a></code></pre></div>
<h3 id="gdisk-磁盘分区大于2t">13.4、gdisk 磁盘分区(大于2T)</h3>
<p>1、能够识别大于2TB的磁盘存储空间</p>
<p>2、可以支持分区的数量 高达 128个 主分区 没有扩展，逻辑分区的概念。</p>
<p>3、MBR 磁盘 和 GPT 不能互相转换、容易造成数据丢失。</p>
<p><strong>使用gdisk工具分区</strong></p>
<div class="sourceCode" id="cb82"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb82-1" data-line-number="1"><span class="co">#1.安装gdisk，没有gdisk需要yum下载一个</span></a>
<a class="sourceLine" id="cb82-2" data-line-number="2"><span class="ex">yum</span> install gdisk -y</a>
<a class="sourceLine" id="cb82-3" data-line-number="3"></a>
<a class="sourceLine" id="cb82-4" data-line-number="4"></a>
<a class="sourceLine" id="cb82-5" data-line-number="5"><span class="co">#2.创建一个新分区，500MB大小</span></a>
<a class="sourceLine" id="cb82-6" data-line-number="6">[<span class="ex">root@</span> ~]# gdisk /dev/sdb</a>
<a class="sourceLine" id="cb82-7" data-line-number="7"><span class="ex">Command</span> (? for help)<span class="bu">:</span> n     #创建新分区</a>
<a class="sourceLine" id="cb82-8" data-line-number="8"><span class="ex">Partition</span> number (1-128, default 1)<span class="bu">:</span></a>
<a class="sourceLine" id="cb82-9" data-line-number="9"><span class="ex">First</span> sector (34-2097118, default = 2048) <span class="ex">or</span> <span class="dt">{+-}size{KMGTP}</span>:</a>
<a class="sourceLine" id="cb82-10" data-line-number="10"><span class="ex">Last</span> sector (2048-2097118, default = 2097118) <span class="ex">or</span> <span class="dt">{+-}size{KMGTP}</span>: +500M <span class="co">#分配500M大小</span></a>
<a class="sourceLine" id="cb82-11" data-line-number="11"></a>
<a class="sourceLine" id="cb82-12" data-line-number="12"><span class="ex">Command</span> (? for help)<span class="bu">:</span> p <span class="co">#打印查看</span></a>
<a class="sourceLine" id="cb82-13" data-line-number="13"><span class="ex">Number</span>  Start (sector)    <span class="ex">End</span> (sector)  <span class="ex">Size</span>       Code  Name</a>
<a class="sourceLine" id="cb82-14" data-line-number="14">   <span class="ex">1</span>            2048         1026047   500.0 MiB   8300  Linux filesystem</a>
<a class="sourceLine" id="cb82-15" data-line-number="15"></a>
<a class="sourceLine" id="cb82-16" data-line-number="16"><span class="ex">Command</span> (? for help)<span class="bu">:</span> w <span class="co">#保存分区</span></a>
<a class="sourceLine" id="cb82-17" data-line-number="17"><span class="ex">Do</span> you want to proceed? (Y/N)<span class="bu">:</span> y    #确认</a>
<a class="sourceLine" id="cb82-18" data-line-number="18"><span class="ex">OK</span><span class="kw">;</span> <span class="ex">writing</span> new GUID partition table (GPT) <span class="ex">to</span> /dev/sdb.</a>
<a class="sourceLine" id="cb82-19" data-line-number="19"><span class="ex">The</span> operation has completed successfully.</a>
<a class="sourceLine" id="cb82-20" data-line-number="20"></a>
<a class="sourceLine" id="cb82-21" data-line-number="21"></a>
<a class="sourceLine" id="cb82-22" data-line-number="22"><span class="co">#3.创建完成后，可以尝试检查磁盘是否为gpt格式</span></a>
<a class="sourceLine" id="cb82-23" data-line-number="23">[<span class="ex">root@xuliangwei-node1</span> /]# fdisk /dev/sdb -l<span class="kw">|</span><span class="fu">grep</span> type</a>
<a class="sourceLine" id="cb82-24" data-line-number="24"><span class="ex">Disk</span> label type: gpt</a>
<a class="sourceLine" id="cb82-25" data-line-number="25"></a>
<a class="sourceLine" id="cb82-26" data-line-number="26"><span class="co">#4.安装parted, 刷新内核立即生效,无需重启</span></a>
<a class="sourceLine" id="cb82-27" data-line-number="27">[<span class="ex">root@</span> ~]# yum -y install parted</a>
<a class="sourceLine" id="cb82-28" data-line-number="28">[<span class="ex">root@</span> ~]# partprobe /dev/sdb</a>
<a class="sourceLine" id="cb82-29" data-line-number="29"></a>
<a class="sourceLine" id="cb82-30" data-line-number="30"><span class="ex">2.</span>使用mkfs进行格式化磁盘。前面已经介绍过，此处不反复介绍。</a>
<a class="sourceLine" id="cb82-31" data-line-number="31">[<span class="ex">root@xuliangwei</span> ~]# mkfs.xfs  /dev/sdb</a>
<a class="sourceLine" id="cb82-32" data-line-number="32"></a>
<a class="sourceLine" id="cb82-33" data-line-number="33"><span class="ex">3.</span>使用mount命令将某个目录挂载该分区，进行使用。</a>
<a class="sourceLine" id="cb82-34" data-line-number="34">[<span class="ex">root@</span> ~]# mkdir /data_gdisk</a>
<a class="sourceLine" id="cb82-35" data-line-number="35">[<span class="ex">root@</span> ~]# mount /dev/sdb /data_gdisk</a></code></pre></div>
<h3 id="swap-物理内存">13.5、swap 物理内存</h3>
<p>Swap分区在系统的物理内存不够时，将硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。</p>
<p><strong>PS: 当物理内存不够时会随机kill占用内存的进程，从而产生oom，临时使用swap可以解决。</strong></p>
<div class="sourceCode" id="cb83"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb83-1" data-line-number="1">[<span class="ex">root@container</span> ~]# swapoff -a          #临时取消swap分区</a>
<a class="sourceLine" id="cb83-2" data-line-number="2">[<span class="ex">root@container</span> ~]# free -m             #查看swap分区</a>
<a class="sourceLine" id="cb83-3" data-line-number="3">[<span class="ex">root@container</span> ~]# swapon -a           #开启swap分区</a></code></pre></div>
<p><strong>如何将磁盘空间划分一部分给swap使用</strong></p>
<pre><code>1.先找一块硬盘，划分1Gb空间          fdisk
2.格式化为一个swap的设备            mkswap /dev/sdb1                #格式化前要先卸载挂载
3.通过                            swapon -a /dev/sdb1  将该设备加入swap
4.使用free -m 检查swap的大小        free -m
5.如果不想使用swap了                swapoff /dev/sdb1   移除</code></pre>
<p><strong>——如上操作都是临时的，如需永久生效，需要添加到/etc/fstab！！！！！！</strong></p>
<h3 id="df-du查看磁盘空间">13.6 、df 、du查看磁盘空间</h3>
<p><strong>df 使用</strong></p>
<div class="sourceCode" id="cb85"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="co">#参数</span></a>
<a class="sourceLine" id="cb85-2" data-line-number="2"><span class="ex">-h</span>          #以人类可读的方式显示(GB\MB\KB)磁盘使用情况</a>
<a class="sourceLine" id="cb85-3" data-line-number="3"><span class="ex">-T</span>          #显示各个文件系统的类型。</a>
<a class="sourceLine" id="cb85-4" data-line-number="4"><span class="ex">--total</span>     #将在输出列表的底部显示总计信息</a>
<a class="sourceLine" id="cb85-5" data-line-number="5"><span class="ex">-i</span>          #显示 inode 信息</a></code></pre></div>
<p><strong>du 使用</strong></p>
<p><code>du</code> 命令查找目录下占用空间较大的文件和子目录</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="fu">du</span> -a /path/to/directory <span class="kw">|</span> <span class="fu">sort</span> -n -r <span class="kw">|</span> <span class="fu">head</span> -n N</a>
<a class="sourceLine" id="cb86-2" data-line-number="2"></a>
<a class="sourceLine" id="cb86-3" data-line-number="3">其中：</a>
<a class="sourceLine" id="cb86-4" data-line-number="4"><span class="ex">/path/to/directory</span> 是您要检查的目录路径，可以是相对路径或绝对路径。</a>
<a class="sourceLine" id="cb86-5" data-line-number="5"><span class="ex">N</span> 是您希望查看的最大文件／子目录的数量。</a></code></pre></div>
<p>区别</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb87-1" data-line-number="1"><span class="fu">du</span> 和 df 都是用于检查磁盘空间的 Unix、Linux 和 macOS 系统命令。尽管它们都与磁盘空间分析相关，但它们的功能和目标有所不同。</a>
<a class="sourceLine" id="cb87-2" data-line-number="2"></a>
<a class="sourceLine" id="cb87-3" data-line-number="3"><span class="co">#du（Disk Usage）:</span></a>
<a class="sourceLine" id="cb87-4" data-line-number="4"><span class="fu">du</span> 主要用于分析文件和目录占用的磁盘空间。它可以报告给定文件或目录（及其子目录）的磁盘使用情况，并显示详细信息。du 允许按文件和目录查找磁盘使用情况，并按需深入到嵌套子目录中。</a>
<a class="sourceLine" id="cb87-5" data-line-number="5"></a>
<a class="sourceLine" id="cb87-6" data-line-number="6">一些常见的 <span class="fu">du</span> 用法：</a>
<a class="sourceLine" id="cb87-7" data-line-number="7">显示指定目录及其子目录的大小：<span class="ex">du</span> /path/to/directory</a>
<a class="sourceLine" id="cb87-8" data-line-number="8">以人类可读的格式显示目录大小：<span class="ex">du</span> -h /path/to/directory</a>
<a class="sourceLine" id="cb87-9" data-line-number="9">显示指定文件的大小：<span class="ex">du</span> -h /path/to/file</a>
<a class="sourceLine" id="cb87-10" data-line-number="10"></a>
<a class="sourceLine" id="cb87-11" data-line-number="11"><span class="co">#df（Disk Free）:</span></a>
<a class="sourceLine" id="cb87-12" data-line-number="12"><span class="fu">df</span> 主要用于显示整个文件系统、挂载点或磁盘分区的磁盘空间使用情况。它提供了关于整个文件系统的统计数据，如总空间、已用空间、可用空间等。df 不会深入到文件或子目录级别，但可以给出关于整个文件系统的总体概述。</a>
<a class="sourceLine" id="cb87-13" data-line-number="13"></a>
<a class="sourceLine" id="cb87-14" data-line-number="14">一些常见的 <span class="fu">df</span> 用法：</a>
<a class="sourceLine" id="cb87-15" data-line-number="15">显示所有文件系统的磁盘空间使用情况：<span class="ex">df</span></a>
<a class="sourceLine" id="cb87-16" data-line-number="16">以人类可读的格式显示磁盘使用情况：<span class="ex">df</span> -h</a>
<a class="sourceLine" id="cb87-17" data-line-number="17">显示指定文件系统的磁盘使用情况：<span class="ex">df</span> /path/to/mount/point</a>
<a class="sourceLine" id="cb87-18" data-line-number="18"></a>
<a class="sourceLine" id="cb87-19" data-line-number="19"><span class="co">#总之，du 用于深入查找特定文件和目录的磁盘占用情况，而 df 用于查看整个文件系统或磁盘分区的磁盘空间使用概况。两者都是磁盘空间分析工具，但用途和焦点不同。</span></a></code></pre></div>
<h3 id="inode使用查询">13.7 inode使用查询</h3>
<div class="sourceCode" id="cb88"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="ex">1</span>、使用 df 命令查看文件系统的 inode 使用情况。使用 -i 选项显示 inode 信息：</a>
<a class="sourceLine" id="cb88-2" data-line-number="2"><span class="co"># df -i</span></a>
<a class="sourceLine" id="cb88-3" data-line-number="3"></a>
<a class="sourceLine" id="cb88-4" data-line-number="4"><span class="ex">2</span>、要查找拥有大量 inode 的目录，可以使用 find 命令配合 wc -l 命令，例如：</a>
<a class="sourceLine" id="cb88-5" data-line-number="5"><span class="kw">for</span> <span class="ex">i</span> in /*<span class="kw">;</span> <span class="kw">do</span> <span class="bu">echo</span> -n <span class="st">&quot;</span><span class="va">$i</span><span class="st">: &quot;</span> <span class="kw">&amp;&amp;</span> <span class="fu">find</span> <span class="st">&quot;</span><span class="va">$i</span><span class="st">&quot;</span> -print <span class="kw">|</span> <span class="fu">wc</span> -l<span class="kw">;</span> <span class="kw">done</span> <span class="kw">|</span> <span class="fu">sort</span> -n -k2 -r</a>
<a class="sourceLine" id="cb88-6" data-line-number="6"></a>
<a class="sourceLine" id="cb88-7" data-line-number="7">这条命令递归遍历根目录（/<span class="ex">*</span>）下的所有子目录，并显示每个目录占用的 inode 数量，按降序排列。</a></code></pre></div>
<p><strong>inode 的管理对于确保文件系统正常工作和优化磁盘空间使用极为重要。在进行磁盘监控和优化时，请确保关注 inode 使用情况。</strong></p>
<h2 id="进程管理">14. 进程管理</h2>
<p><strong>程序在运行后，我们需要了解进程的运行状态。查看进程的状态分为: 静态和动态两种方式</strong></p>
<p><strong>ps:每个进程的父进程都叫PPID,子进程则叫PID</strong></p>
<h3 id="ps-aux-静态进程信息查看">14.1 ps aux 静态进程信息查看</h3>
<div class="sourceCode" id="cb89"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb89-1" data-line-number="1"><span class="co">#常用参数</span></a>
<a class="sourceLine" id="cb89-2" data-line-number="2"><span class="fu">ps</span>              #显示当前终端内的进程</a>
<a class="sourceLine" id="cb89-3" data-line-number="3"><span class="fu">ps</span> -e           #显示全部进程</a>
<a class="sourceLine" id="cb89-4" data-line-number="4"><span class="fu">ps</span> -ef          #以完整的格式显示全部进程</a>
<a class="sourceLine" id="cb89-5" data-line-number="5"><span class="fu">ps</span> -u username  #显示指定用户运行的进程</a>
<a class="sourceLine" id="cb89-6" data-line-number="6"><span class="fu">ps</span> -l           #长格式显示当前终端内的进程信息</a>
<a class="sourceLine" id="cb89-7" data-line-number="7"><span class="fu">ps</span> -aux         #显示系统中所有用户的进程信息，而无论它们是否与终端关联。</a></code></pre></div>
<div class="sourceCode" id="cb90"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="ex">USER</span>            进程运行的用户身份（ 每一个进程，都需要一个特定的用户身份来运行 ）</a>
<a class="sourceLine" id="cb90-2" data-line-number="2"><span class="ex">PID</span>             子进程的身份标识 （ 就是一种标识，用来区分不同的进程 ）</a>
<a class="sourceLine" id="cb90-3" data-line-number="3"><span class="ex">%CPU</span>            该进程占用CPU的百分比是多少</a>
<a class="sourceLine" id="cb90-4" data-line-number="4"><span class="ex">%MEM</span>            该进程占用内存的百分比是多少</a>
<a class="sourceLine" id="cb90-5" data-line-number="5"><span class="ex">VSZ</span>             虚拟内存</a>
<a class="sourceLine" id="cb90-6" data-line-number="6"><span class="ex">RSS</span>             实际占用内存   </a>
<a class="sourceLine" id="cb90-7" data-line-number="7"><span class="ex">TTY</span>             该进程是哪个终端运行的  ? 表示是系统运行的 pts/0 pts/1 来源的终端是哪一个</a>
<a class="sourceLine" id="cb90-8" data-line-number="8"><span class="ex">STAT</span>            进程所表示的状态（ 运行 暂停 停止 .......）</a>
<a class="sourceLine" id="cb90-9" data-line-number="9"><span class="ex">START</span>           进程启动时间</a>
<a class="sourceLine" id="cb90-10" data-line-number="10"><span class="ex">TIME</span>            进程占用CPU的时间</a>
<a class="sourceLine" id="cb90-11" data-line-number="11"><span class="ex">COMMAND</span>         运行该进程需要执行的命令    [ ] 表示内核启动的进程</a>
<a class="sourceLine" id="cb90-12" data-line-number="12"></a>
<a class="sourceLine" id="cb90-13" data-line-number="13"></a>
<a class="sourceLine" id="cb90-14" data-line-number="14"><span class="co">#STAT状态</span></a>
<a class="sourceLine" id="cb90-15" data-line-number="15"><span class="ex">-</span> STAT基本状态——描述                      </a>
<a class="sourceLine" id="cb90-16" data-line-number="16">  <span class="ex">R</span> ：进程运行                               </a>
<a class="sourceLine" id="cb90-17" data-line-number="17">  <span class="ex">S</span> ：可中断进程                      </a>
<a class="sourceLine" id="cb90-18" data-line-number="18">  <span class="ex">T</span> ：进程被暂停                          </a>
<a class="sourceLine" id="cb90-19" data-line-number="19">  <span class="ex">D</span> ：不可中断进程                     </a>
<a class="sourceLine" id="cb90-20" data-line-number="20">  <span class="ex">Z</span> ：僵尸进程                               </a>
<a class="sourceLine" id="cb90-21" data-line-number="21"><span class="ex">-</span> STAT状态+符号——描述</a>
<a class="sourceLine" id="cb90-22" data-line-number="22">  <span class="ex">s</span> ：进程是控制进程， Ss进程的领导者，父进程</a>
<a class="sourceLine" id="cb90-23" data-line-number="23">  <span class="op">&lt;</span> ：进程运行在高优先级上，<span class="ex">S</span><span class="op">&lt;</span>优先级较高的进程</a>
<a class="sourceLine" id="cb90-24" data-line-number="24">  <span class="ex">N</span> ：进程运行在低优先级上，SN优先级较低的进程</a>
<a class="sourceLine" id="cb90-25" data-line-number="25">  ＋：当前进程运行在前台，<span class="ex">R+</span>该表示进程在前台运行</a>
<a class="sourceLine" id="cb90-26" data-line-number="26">  <span class="ex">l</span> ：进程是多线程的，Sl表示进程是以线程方式运行</a></code></pre></div>
<h3 id="top-动态查看">14.2 top 动态查看</h3>
<p>w: 11:20:10 up 6 days, 7:46, 2 users, load average: 0.01, 0.02, 0.05 uptime: 11:20:14 up 6 days, 7:46, 2 users, load average: 0.01, 0.02, 0.05</p>
<p>top:查看前三行显示信息 第一行,任务对列信息同uptime命令执行结果一样</p>
<ul>
<li>top - 11:18:15 up 6 days, 7:44, 2 users, load average: 0.08, 0.03, 0.06</li>
</ul>
<blockquote>
<p>11:18:15 当前系统时间 up 6 days,7:44 系统运行天数,小时 2 users 当前2个用户登录 load average: 0.08, 0.03, 0.06 后面三组数分别是1分钟,五分钟,十五分钟的负载情况</p>
</blockquote>
<p>第二行,tasks-任务(进程) Tasks: 112 total, 1 running, 110 sleeping, 1 stopped, 0 zombie</p>
<blockquote>
<p>系统共有112个进程,其中处于运行的1个,110个在休眠(sleep),stopped状态的1个,zombie状态(僵尸)的有零个</p>
</blockquote>
<p>第三行,CPU状态信息 %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb91-1" data-line-number="1"><span class="ex">us</span>: 用户进程占用cpu百分比（ 视频加密、视频解码 ）</a>
<a class="sourceLine" id="cb91-2" data-line-number="2"><span class="ex">sy</span>: 内核进程占用cpu百分比 （ 比如 网卡、硬件设备、硬盘 ）</a>
<a class="sourceLine" id="cb91-3" data-line-number="3"><span class="ex">ni</span>: 优先级高的进程占用cpu百分比  </a>
<a class="sourceLine" id="cb91-4" data-line-number="4"><span class="ex">id</span>: 空闲的百分比 （ 值越大、说明服务器越空闲 ）</a>
<a class="sourceLine" id="cb91-5" data-line-number="5"><span class="ex">wa</span>: 用户请求磁盘资源，磁盘很慢慢慢，请求的资源很多,会造成大量的等待程序    （ 数据库 ）</a>
<a class="sourceLine" id="cb91-6" data-line-number="6"><span class="ex">hi</span>: 硬中断</a>
<a class="sourceLine" id="cb91-7" data-line-number="7"><span class="ex">si</span>: 软中断</a>
<a class="sourceLine" id="cb91-8" data-line-number="8"><span class="ex">st</span>: 当该服务器运行了很多的虚拟机，这些虚拟机总共占用当前物理服务器的百分比是多少</a></code></pre></div>
<p>不可能用top去每台服务器观察，后期将所有的服务器通过监控，统一的监控起来。 top 常见指令</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb92-1" data-line-number="1">字母                          含义</a>
<a class="sourceLine" id="cb92-2" data-line-number="2"><span class="ex">h</span>                       查看帮助</a>
<a class="sourceLine" id="cb92-3" data-line-number="3"><span class="ex">1</span>                       数字1，显示所有CPU核心的负载</a>
<a class="sourceLine" id="cb92-4" data-line-number="4"><span class="ex">z</span>                       以高亮显示数据</a>
<a class="sourceLine" id="cb92-5" data-line-number="5"><span class="ex">b</span>                       高亮显示处于R状态的进程</a>
<a class="sourceLine" id="cb92-6" data-line-number="6"><span class="ex">M</span>                       按内存使用百分比排序输出</a>
<a class="sourceLine" id="cb92-7" data-line-number="7"><span class="ex">P</span>                       按CPU使用百分比排序输出</a>
<a class="sourceLine" id="cb92-8" data-line-number="8"><span class="ex">q</span>                       退出top</a></code></pre></div>
<p>总结</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb93-1" data-line-number="1"><span class="op">&gt;</span><span class="ex">1.</span>进程的生命周期</a>
<a class="sourceLine" id="cb93-2" data-line-number="2">    僵尸进程（会占用资源）</a>
<a class="sourceLine" id="cb93-3" data-line-number="3">    孤儿进程（）</a>
<a class="sourceLine" id="cb93-4" data-line-number="4"><span class="ex">2.</span>系统指标监控</a>
<a class="sourceLine" id="cb93-5" data-line-number="5">    <span class="fu">ps</span>  静态</a>
<a class="sourceLine" id="cb93-6" data-line-number="6">    <span class="ex">top</span> 动态</a>
<a class="sourceLine" id="cb93-7" data-line-number="7"><span class="ex">3.</span>中断</a>
<a class="sourceLine" id="cb93-8" data-line-number="8">    软中断 硬中断</a></code></pre></div>
<h4 id="nice-进程优先级">nice 进程优先级</h4>
<p>在启动进程时，为不同的进程使用不同的调度策略。 nice 值越高： 表示优先级越低，例如+19，该进程容易将CPU 使用量让给其他进程。 nice 值越低： 表示优先级越高，例如-20，该进程不倾向于让出CPU。 最高的优先级</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb94-1" data-line-number="1">低       正常      高</a>
<a class="sourceLine" id="cb94-2" data-line-number="2"><span class="ex">+20</span>      0       -20</a></code></pre></div>
<p><strong>nice 指定程序运行优先级</strong></p>
<div class="sourceCode" id="cb95"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="co">#语法格式 </span></a>
<a class="sourceLine" id="cb95-2" data-line-number="2"><span class="fu">nice</span> -n 优先级数字 进程名称</a>
<a class="sourceLine" id="cb95-3" data-line-number="3"></a>
<a class="sourceLine" id="cb95-4" data-line-number="4"><span class="co">#1.开启vim并且指定程序优先级为-5</span></a>
<a class="sourceLine" id="cb95-5" data-line-number="5">[<span class="ex">root@m01</span> ~]# nice -n -5 vim <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb95-6" data-line-number="6">[<span class="ex">1</span>] 98417</a>
<a class="sourceLine" id="cb95-7" data-line-number="7"></a>
<a class="sourceLine" id="cb95-8" data-line-number="8"><span class="co">#2.查看该进程的优先级情况</span></a>
<a class="sourceLine" id="cb95-9" data-line-number="9">[<span class="ex">root@m01</span> ~]# ps axo pid,command,nice <span class="kw">|</span><span class="fu">grep</span> 98417</a>
<a class="sourceLine" id="cb95-10" data-line-number="10"> <span class="ex">98417</span> vim                         -5</a></code></pre></div>
<p><strong>renice 修改正在运行程序的优先级</strong></p>
<div class="sourceCode" id="cb96"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb96-1" data-line-number="1"><span class="co">#语法格式 </span></a>
<a class="sourceLine" id="cb96-2" data-line-number="2"><span class="ex">renice</span> -n 优先级数字 进程pid</a>
<a class="sourceLine" id="cb96-3" data-line-number="3"></a>
<a class="sourceLine" id="cb96-4" data-line-number="4"><span class="co">#1.查看vim的进程id,名称,nice(优先级)</span></a>
<a class="sourceLine" id="cb96-5" data-line-number="5">[<span class="ex">root@syc</span>~]# ps axo pid,command,nice <span class="kw">|</span><span class="fu">grep</span> vim <span class="kw">|</span><span class="fu">grep</span> -v grep    #查找后进行过滤</a>
<a class="sourceLine" id="cb96-6" data-line-number="6"> <span class="ex">3621</span> vim                         -20</a>
<a class="sourceLine" id="cb96-7" data-line-number="7"></a>
<a class="sourceLine" id="cb96-8" data-line-number="8"><span class="co">#2.修改vim的优先级为-20</span></a>
<a class="sourceLine" id="cb96-9" data-line-number="9">[<span class="ex">root@syc</span>~]# renice -n -20 3621</a>
<a class="sourceLine" id="cb96-10" data-line-number="10"><span class="ex">3621</span> (进程 ID) 旧优先级为 <span class="ex">0</span>，新优先级为 -20</a>
<a class="sourceLine" id="cb96-11" data-line-number="11"></a>
<a class="sourceLine" id="cb96-12" data-line-number="12"><span class="co">#3.查看vim的优先级(这个过滤的是id号,什么过滤的是名字)</span></a>
<a class="sourceLine" id="cb96-13" data-line-number="13">[<span class="ex">root@syc</span>~]# ps axo pid,command,nice <span class="kw">|</span><span class="fu">grep</span> 3621</a>
<a class="sourceLine" id="cb96-14" data-line-number="14"> <span class="ex">3621</span> vim                         -20</a>
<a class="sourceLine" id="cb96-15" data-line-number="15"> <span class="ex">3629</span> grep --color=auto 3621      -20</a></code></pre></div>
<h3 id="kill-管理进程状态">14.3 kill 管理进程状态</h3>
<p>当程序运行为进程后，如果希望停止进程，怎么办呢? 那么此时我们可以使用linux的kill命令对进程发送关闭信号。当然除了kill、还有killall，pkill</p>
<p>1.使用kill -l列出当前系统所支持的信号</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="co"># kill -l</span></a></code></pre></div>
<p>虽然linux支持信号很多，但是我们仅列出我们最为常用的3个信号</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">数字编号</th>
<th style="text-align: left;">信号含义</th>
<th style="text-align: left;">信号翻译</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">SIGHUP</td>
<td style="text-align: left;">通常用来重新加载配置文件</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: left;">SIGKILL</td>
<td style="text-align: left;">强制杀死进程</td>
</tr>
<tr class="odd">
<td style="text-align: left;">15</td>
<td style="text-align: left;">SIGTERM</td>
<td style="text-align: left;">终止进程，默认kill使用该信号</td>
</tr>
</tbody>
</table>
<p>Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而<strong>killall</strong>、<strong>pkill</strong>把这两个过程合二为一，是一个很好用的命令。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb98-1" data-line-number="1"><span class="co">#1、通过服务名称杀掉进程</span></a>
<a class="sourceLine" id="cb98-2" data-line-number="2">[<span class="ex">root@syc</span>~]# killall vsftpd</a>
<a class="sourceLine" id="cb98-3" data-line-number="3">[<span class="ex">root@syc</span>~]# pkill vsftpd</a>
<a class="sourceLine" id="cb98-4" data-line-number="4"><span class="co">#2.使用pkill踢出从远程登录到本机的用户，终止pts/0上所有进程, 并且bash也结束（用户被强制退出）</span></a>
<a class="sourceLine" id="cb98-5" data-line-number="5">[<span class="ex">root@syc</span>~]# pkill -9 -t pts/0</a></code></pre></div>
<h3 id="jobsbgfg的使用">14.4 jobs、bg、fg的使用</h3>
<div class="sourceCode" id="cb99"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb99-1" data-line-number="1">[<span class="ex">root@xuliangwei</span> ~]# sleep 3000 <span class="kw">&amp;</span>       <span class="ex">/</span>/运行程序<span class="kw">(</span>时<span class="kw">)</span>，让其在后台执行 </a>
<a class="sourceLine" id="cb99-2" data-line-number="2">[<span class="ex">root@xuliangwei</span> ~]# sleep 4000         //^Z,将前台的程序挂起(暂停)到后台 </a>
<a class="sourceLine" id="cb99-3" data-line-number="3">[<span class="ex">2</span>]+ Stopped sleep 4000</a>
<a class="sourceLine" id="cb99-4" data-line-number="4">[<span class="ex">root@xuliangwei</span> ~]# ps aux <span class="kw">|</span><span class="fu">grep</span> sleep</a>
<a class="sourceLine" id="cb99-5" data-line-number="5">[<span class="ex">root@xuliangwei</span> ~]# jobs               //查看后台作业</a>
<a class="sourceLine" id="cb99-6" data-line-number="6">[<span class="ex">1</span>]- Running sleep 3000 <span class="kw">&amp;</span> </a>
<a class="sourceLine" id="cb99-7" data-line-number="7">[<span class="ex">2</span>]+ Stopped sleep 4000</a>
<a class="sourceLine" id="cb99-8" data-line-number="8"></a>
<a class="sourceLine" id="cb99-9" data-line-number="9">[<span class="ex">root@xuliangwei</span> ~]# bg %2              //让作业 2 在后台运行</a>
<a class="sourceLine" id="cb99-10" data-line-number="10">[<span class="ex">root@xuliangwei</span> ~]# fg %1              //将作业 1 调回到前台</a>
<a class="sourceLine" id="cb99-11" data-line-number="11">[<span class="ex">root@xuliangwei</span> ~]# kill %1            //kill 1，终止 PID 为 1 的进程</a>
<a class="sourceLine" id="cb99-12" data-line-number="12"></a>
<a class="sourceLine" id="cb99-13" data-line-number="13">[<span class="ex">root@xuliangwei</span> ~]# (while :<span class="kw">;</span> <span class="kw">do</span> <span class="fu">date</span><span class="kw">;</span> <span class="fu">sleep</span> 2<span class="kw">;</span> <span class="kw">done</span>) <span class="kw">&amp;</span> <span class="ex">/</span>/进程在后台运行，但输出依然在当前终端</a>
<a class="sourceLine" id="cb99-14" data-line-number="14">[<span class="ex">root@xuliangwei</span> ~]# (while :<span class="kw">;</span> <span class="kw">do</span> <span class="fu">date</span><span class="kw">;</span> <span class="fu">sleep</span> 2<span class="kw">;</span> <span class="kw">done</span>) <span class="op">&amp;&gt;</span><span class="ex">/dev/null</span> <span class="kw">&amp;</span></a></code></pre></div>
<h3 id="screen-管理后台进程">14.5 screen 管理后台进程</h3>
<div class="sourceCode" id="cb100"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb100-1" data-line-number="1">选项:</a>
<a class="sourceLine" id="cb100-2" data-line-number="2"><span class="ex">-list</span>       查看打开的新窗口</a>
<a class="sourceLine" id="cb100-3" data-line-number="3"><span class="ex">-r</span>          加窗口id   进入窗口</a>
<a class="sourceLine" id="cb100-4" data-line-number="4"><span class="ex">-s</span>          指定窗口名称</a>
<a class="sourceLine" id="cb100-5" data-line-number="5"></a>
<a class="sourceLine" id="cb100-6" data-line-number="6"><span class="co">#1.打开新的窗口</span></a>
<a class="sourceLine" id="cb100-7" data-line-number="7">[<span class="ex">root@syc</span>~]# screen </a>
<a class="sourceLine" id="cb100-8" data-line-number="8"><span class="ex">2.</span>指定打开一个名字为wyk的窗口-----加大S</a>
<a class="sourceLine" id="cb100-9" data-line-number="9">[<span class="ex">root@syc</span>~]# screen -S WYK</a>
<a class="sourceLine" id="cb100-10" data-line-number="10">[<span class="ex">root@syc</span>~]# screen -list               ##查看所有窗口--------加-list</a>
<a class="sourceLine" id="cb100-11" data-line-number="11"><span class="ex">There</span> is a screen on:</a>
<a class="sourceLine" id="cb100-12" data-line-number="12">        <span class="ex">3285.WYK</span>        (Attached)</a>
<a class="sourceLine" id="cb100-13" data-line-number="13"><span class="ex">1</span> Socket in /var/run/screen/S-root.</a>
<a class="sourceLine" id="cb100-14" data-line-number="14"></a>
<a class="sourceLine" id="cb100-15" data-line-number="15">现在已经在新打开的<span class="ex">wyk</span>窗口下可以执行一个top查看进程状态,Ctrl+a+d平滑退出窗口,这个命令还会在后台运行,</a>
<a class="sourceLine" id="cb100-16" data-line-number="16">就算关了终端也不会退出,也是需要<span class="ex">exit</span>来关闭新建的screen窗口</a>
<a class="sourceLine" id="cb100-17" data-line-number="17"></a>
<a class="sourceLine" id="cb100-18" data-line-number="18"><span class="co">#2平滑的退出screen,但不会终止screen中的任务。注意: 如果使用exit 才算真的关闭screen窗口</span></a>
<a class="sourceLine" id="cb100-19" data-line-number="19"></a>
<a class="sourceLine" id="cb100-20" data-line-number="20"><span class="co">#3进入正在运行的screen  -r可以加id号也可以加名字进入</span></a>
<a class="sourceLine" id="cb100-21" data-line-number="21">[<span class="ex">root@syc</span>~]# screen -r wyk</a>
<a class="sourceLine" id="cb100-22" data-line-number="22">[<span class="ex">root@syc</span>~]# screen -r 3285</a></code></pre></div>
<h2 id="crond-计划任务">15. crond 计划任务</h2>
<p>1.系统级别的定时任务： 临时文件清理、系统信息采集、日志文件切割</p>
<p>2.用户级别的定时任务： 定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb101-1" data-line-number="1">[<span class="ex">root@</span> ~]# vim /etc/crontab</a>
<a class="sourceLine" id="cb101-2" data-line-number="2"><span class="va">SHELL=</span>/bin/bash                     #执行命令的解释器</a>
<a class="sourceLine" id="cb101-3" data-line-number="3"><span class="va">PATH=</span>/sbin:/bin:/usr/sbin:/usr/bin  #环境变量</a>
<a class="sourceLine" id="cb101-4" data-line-number="4"><span class="va">MAILTO=</span>root                         #邮件发给谁</a>
<a class="sourceLine" id="cb101-5" data-line-number="5"><span class="co"># Example of job definition:</span></a>
<a class="sourceLine" id="cb101-6" data-line-number="6"><span class="co"># .---------------- minute (0 - 59) #分钟</span></a>
<a class="sourceLine" id="cb101-7" data-line-number="7"><span class="co"># |  .------------- hour (0 - 23)   #小时</span></a>
<a class="sourceLine" id="cb101-8" data-line-number="8"><span class="co"># |  |  .---------- day of month (1 - 31)   #日期</span></a>
<a class="sourceLine" id="cb101-9" data-line-number="9"><span class="co"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr #月份</span></a>
<a class="sourceLine" id="cb101-10" data-line-number="10"><span class="co"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat  #星期</span></a>
<a class="sourceLine" id="cb101-11" data-line-number="11"><span class="co"># |  |  |  |  |</span></a>
<a class="sourceLine" id="cb101-12" data-line-number="12"><span class="co"># *  *  *  *  *   command to be executed</span></a>
<a class="sourceLine" id="cb101-13" data-line-number="13"></a>
<a class="sourceLine" id="cb101-14" data-line-number="14"><span class="co"># *  表示任意的(分、时、日、月、周)时间都执行</span></a>
<a class="sourceLine" id="cb101-15" data-line-number="15"><span class="co"># -  表示一个时间范围段, 如5-7点</span></a>
<a class="sourceLine" id="cb101-16" data-line-number="16"><span class="co"># ,  表示分隔时段, 如6,0,4表示周六、日、四</span></a>
<a class="sourceLine" id="cb101-17" data-line-number="17"><span class="co"># /1 表示每隔n单位时间, 如*/10 每10分钟</span></a></code></pre></div>
<p>2.了解crontab的时间编写规范</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb102-1" data-line-number="1"><span class="ex">00</span> 02 * * * ls      #每天的凌晨2点整执行</a>
<a class="sourceLine" id="cb102-2" data-line-number="2"><span class="ex">00</span> 02 1 * * ls      #每月的1日的凌晨2点整执行</a>
<a class="sourceLine" id="cb102-3" data-line-number="3"><span class="ex">00</span> 02 14 2 * ls     #每年的2月14日凌晨2点执行</a>
<a class="sourceLine" id="cb102-4" data-line-number="4"><span class="ex">00</span> 02 * * 7 ls      #每周天的凌晨2点整执行</a>
<a class="sourceLine" id="cb102-5" data-line-number="5"><span class="ex">00</span> 02 * 6 5 ls      #每年的6月周五凌晨2点执行</a>
<a class="sourceLine" id="cb102-6" data-line-number="6"><span class="ex">00</span> 02 14 * 7 ls     #每月14日或每周日的凌晨2点都执行</a>
<a class="sourceLine" id="cb102-7" data-line-number="7"><span class="ex">00</span> 02 14 2 7 ls     #每年的2月14日或每年2月的周天的凌晨2点执行   </a>
<a class="sourceLine" id="cb102-8" data-line-number="8"><span class="ex">*/10</span>  02 * * * ls   #每天凌晨2点，每隔10分钟执行一次</a>
<a class="sourceLine" id="cb102-9" data-line-number="9"><span class="ex">*</span> * * * *  ls       #每分钟都执行</a>
<a class="sourceLine" id="cb102-10" data-line-number="10"><span class="ex">00</span> 00 14 2 *  ls    #每年2月14日的凌晨执行命令 </a>
<a class="sourceLine" id="cb102-11" data-line-number="11"><span class="ex">*/5</span> * * * *  ls     #每隔5分钟执行一次</a>
<a class="sourceLine" id="cb102-12" data-line-number="12"><span class="ex">00</span> 02 * 1,5,8 * ls  #每年的1月5月8月凌晨2点执行</a>
<a class="sourceLine" id="cb102-13" data-line-number="13"><span class="ex">00</span> 02 1-8 * *  ls    #每月1号到8号凌晨2点执行</a>
<a class="sourceLine" id="cb102-14" data-line-number="14"><span class="ex">0</span> 21 * * * ls       #每天晚上21:00执行</a>
<a class="sourceLine" id="cb102-15" data-line-number="15"><span class="ex">45</span> 4 1,10,22 * * ls <span class="co">#每月1、10、22日的4:45执行</span></a>
<a class="sourceLine" id="cb102-16" data-line-number="16"><span class="ex">45</span> 4 1-10 * * l     #每月1到10日的4:45执行</a>
<a class="sourceLine" id="cb102-17" data-line-number="17"><span class="ex">3</span>,15 8-11 */2 * * ls <span class="co">#每隔两天的上午8点到11点的第3和第15分钟执行</span></a>
<a class="sourceLine" id="cb102-18" data-line-number="18"><span class="ex">0</span> 23-7/1 * * * ls   #晚上11点到早上7点之间，每隔一小时执行</a>
<a class="sourceLine" id="cb102-19" data-line-number="19"><span class="ex">15</span> 21 * * 1-5 ls    #周一到周五每天晚上21:15执行</a></code></pre></div>
<h3 id="crontab使用"><strong>crontab使用</strong></h3>
<div class="sourceCode" id="cb103"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb103-1" data-line-number="1"><span class="co">#参数 含义</span></a>
<a class="sourceLine" id="cb103-2" data-line-number="2"><span class="ex">-e</span>  编辑定时任务</a>
<a class="sourceLine" id="cb103-3" data-line-number="3"><span class="ex">-l</span>  查看定时任务</a>
<a class="sourceLine" id="cb103-4" data-line-number="4"><span class="ex">-r</span>  删除定时任务</a>
<a class="sourceLine" id="cb103-5" data-line-number="5"><span class="ex">-u</span>  指定其他用户</a>
<a class="sourceLine" id="cb103-6" data-line-number="6"></a>
<a class="sourceLine" id="cb103-7" data-line-number="7"><span class="ex">1.</span>使用root用户每5分钟执行一次时间同步</a>
<a class="sourceLine" id="cb103-8" data-line-number="8"></a>
<a class="sourceLine" id="cb103-9" data-line-number="9"><span class="co">#1.如何同步时间</span></a>
<a class="sourceLine" id="cb103-10" data-line-number="10">[<span class="ex">root@xuliangwei</span> ~]# ntpdate time.windows.com <span class="op">&amp;&gt;</span>/dev/null</a>
<a class="sourceLine" id="cb103-11" data-line-number="11"><span class="co">#2.配置定时任务</span></a>
<a class="sourceLine" id="cb103-12" data-line-number="12">[<span class="ex">root@xuliangwei</span> ~]# crontab -e -u root</a>
<a class="sourceLine" id="cb103-13" data-line-number="13">[<span class="ex">root@xuliangwei</span> ~]# crontab -l -u root</a>
<a class="sourceLine" id="cb103-14" data-line-number="14"><span class="ex">*/5</span> * * * * ntpdate time.windows.com <span class="op">&amp;&gt;</span>/dev/null</a>
<a class="sourceLine" id="cb103-15" data-line-number="15"></a>
<a class="sourceLine" id="cb103-16" data-line-number="16"><span class="ex">2.</span>每天的下午3,5点，每隔半小时执行一次sync命令</a>
<a class="sourceLine" id="cb103-17" data-line-number="17">[<span class="ex">root@xuliangwei</span> ~]# crontab -l</a>
<a class="sourceLine" id="cb103-18" data-line-number="18"><span class="ex">*/30</span> 15,17 * * * sync <span class="op">&amp;&gt;</span>/dev/null</a>
<a class="sourceLine" id="cb103-19" data-line-number="19"></a>
<a class="sourceLine" id="cb103-20" data-line-number="20"></a>
<a class="sourceLine" id="cb103-21" data-line-number="21"><span class="ex">3.</span>案例：每天凌晨3点做一次备份？备份/etc/目录到/backup下面</a>
<a class="sourceLine" id="cb103-22" data-line-number="22"><span class="ex">1</span>) 将备份命令写入一个脚本中</a>
<a class="sourceLine" id="cb103-23" data-line-number="23"><span class="ex">2</span>) 每天备份文件名要求格式: <span class="ex">2019-05-01_hostname_etc.tar.gz</span></a>
<a class="sourceLine" id="cb103-24" data-line-number="24"><span class="ex">3</span>) 在执行计划任务时，不要输出任务信息</a>
<a class="sourceLine" id="cb103-25" data-line-number="25"><span class="ex">4</span>) 存放备份内容的目录要求只保留三天的数据</a>
<a class="sourceLine" id="cb103-26" data-line-number="26"><span class="co">#1.实现如上备份需求</span></a>
<a class="sourceLine" id="cb103-27" data-line-number="27">[<span class="ex">root@xuliangwei</span> ~]# mkdir /backup</a>
<a class="sourceLine" id="cb103-28" data-line-number="28">[<span class="ex">root@xuliangwei</span> ~]# tar zcf <span class="va">$(</span><span class="fu">date</span> +%F<span class="va">)</span>_<span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>_etc.tar.gz /etc</a>
<a class="sourceLine" id="cb103-29" data-line-number="29">[<span class="ex">root@xuliangwei</span> ~]# find /backup -name “*.tar.gz” -mtime +3 -exec rm -f <span class="dt">{}\;</span></a>
<a class="sourceLine" id="cb103-30" data-line-number="30"></a>
<a class="sourceLine" id="cb103-31" data-line-number="31"><span class="co">#2.将命令写入至一个文件中</span></a>
<a class="sourceLine" id="cb103-32" data-line-number="32">[<span class="ex">root@xuliangwei</span> ~]# vim /root/back.sh</a>
<a class="sourceLine" id="cb103-33" data-line-number="33"><span class="fu">mkdir</span> /backup</a>
<a class="sourceLine" id="cb103-34" data-line-number="34"><span class="fu">tar</span> zcf <span class="va">$(</span><span class="fu">date</span> +%F<span class="va">)</span>_<span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>_etc.tar.gz /etc</a>
<a class="sourceLine" id="cb103-35" data-line-number="35"><span class="fu">find</span> /backup -name “*.tar.gz” -mtime +3 -exec rm -f <span class="dt">{}\;</span></a>
<a class="sourceLine" id="cb103-36" data-line-number="36"></a>
<a class="sourceLine" id="cb103-37" data-line-number="37"><span class="co">#3.配置定时任务</span></a>
<a class="sourceLine" id="cb103-38" data-line-number="38">[<span class="ex">root@xuliangwei</span> ~]# crontab -l</a>
<a class="sourceLine" id="cb103-39" data-line-number="39"><span class="ex">00</span> 03 * * * bash /root/back.sh  <span class="op">&amp;&gt;</span>/dev/null</a>
<a class="sourceLine" id="cb103-40" data-line-number="40"></a>
<a class="sourceLine" id="cb103-41" data-line-number="41"><span class="co">#3.备份脚本</span></a>
<a class="sourceLine" id="cb103-42" data-line-number="42">[<span class="ex">root@container</span> ~]# cat /opt/backup.sh            </a>
<a class="sourceLine" id="cb103-43" data-line-number="43"><span class="co">#!/usr/bin/bash</span></a>
<a class="sourceLine" id="cb103-44" data-line-number="44"> </a>
<a class="sourceLine" id="cb103-45" data-line-number="45"><span class="co">#1.使用tar命令备份/etc目录到backup目录</span></a>
<a class="sourceLine" id="cb103-46" data-line-number="46"><span class="fu">mkdir</span> -p /backup</a>
<a class="sourceLine" id="cb103-47" data-line-number="47"><span class="fu">tar</span> czf /backup/<span class="va">$(</span><span class="fu">date</span> +%F_%H_%M<span class="va">)</span>_<span class="va">$(</span><span class="fu">hostname</span><span class="va">)</span>_etc.tar.gz /etc/</a>
<a class="sourceLine" id="cb103-48" data-line-number="48"> </a>
<a class="sourceLine" id="cb103-49" data-line-number="49"><span class="co">#2.保留最近3天的数据，其余全部删除</span></a>
<a class="sourceLine" id="cb103-50" data-line-number="50"><span class="fu">find</span> /backup -type f -name <span class="st">&quot;*.tar.gz&quot;</span> -mtime +3 -delete</a></code></pre></div>
<p><strong>注意事项</strong></p>
<div class="sourceCode" id="cb104"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb104-1" data-line-number="1"><span class="ex">1</span>) 给定时任务注释</a>
<a class="sourceLine" id="cb104-2" data-line-number="2"><span class="ex">2</span>) 将需要定期执行的任务写入<span class="ex">Shell</span>脚本中，避免直接使用命令无法执行的情况tar date</a>
<a class="sourceLine" id="cb104-3" data-line-number="3"><span class="ex">3</span>) 定时任务的结尾一定要有<span class="op">&amp;&gt;</span><span class="ex">/dev</span>/<span class="ex">null</span>或者将结果追加重定向<span class="op">&gt;&gt;</span>/tmp/date.log文件</a>
<a class="sourceLine" id="cb104-4" data-line-number="4"><span class="ex">4</span>) 注意有些命令是无法成功执行的 <span class="bu">echo</span> <span class="st">&quot;123&quot;</span> <span class="op">&gt;&gt;</span>/tmp/test.log <span class="op">&amp;&gt;</span>/dev/null</a>
<a class="sourceLine" id="cb104-5" data-line-number="5"><span class="ex">5.</span>如果一定要是用命令，命令必须使用绝对路径</a>
<a class="sourceLine" id="cb104-6" data-line-number="6"></a>
<a class="sourceLine" id="cb104-7" data-line-number="7"><span class="ex">5.crond</span>如何备份</a>
<a class="sourceLine" id="cb104-8" data-line-number="8"><span class="ex">1</span>) 通过查找<span class="ex">/var/log</span>/<span class="ex">cron</span>中执行的记录，去推算任务执行的时间</a>
<a class="sourceLine" id="cb104-9" data-line-number="9"><span class="ex">2</span>) 定时的备份<span class="ex">/var/spool/cron</span>/<span class="dt">{usernmae}</span></a>
<a class="sourceLine" id="cb104-10" data-line-number="10"></a>
<a class="sourceLine" id="cb104-11" data-line-number="11"><span class="ex">6.crond</span>如何拒绝某个用户使用</a>
<a class="sourceLine" id="cb104-12" data-line-number="12"><span class="co">#1.使用root将需要拒绝的用户加入/etc/cron.deny</span></a>
<a class="sourceLine" id="cb104-13" data-line-number="13">[<span class="ex">root@</span> ~]# echo <span class="st">&quot;yikun&quot;</span> <span class="op">&gt;&gt;</span> /etc/cron.deny</a>
<a class="sourceLine" id="cb104-14" data-line-number="14"></a>
<a class="sourceLine" id="cb104-15" data-line-number="15"><span class="co">#2.登陆该普通用户，测试是否能编写定时任务</span></a>
<a class="sourceLine" id="cb104-16" data-line-number="16">[<span class="ex">oldboy@yikun</span> ~]$ crontab -e</a>
<a class="sourceLine" id="cb104-17" data-line-number="17"><span class="ex">You</span> (yikun) <span class="ex">are</span> not allowed to use this program (crontab)</a>
<a class="sourceLine" id="cb104-18" data-line-number="18"><span class="ex">See</span> crontab(1) <span class="kw">for</span> <span class="fu">more</span> information</a></code></pre></div>
<p><strong>计划任务如何调试</strong></p>
<div class="sourceCode" id="cb105"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="ex">1.</span>手动执行命令，然后保留执行成功的结果。</a>
<a class="sourceLine" id="cb105-2" data-line-number="2"><span class="ex">2.</span>编写脚本</a>
<a class="sourceLine" id="cb105-3" data-line-number="3">脚本需要统一路径<span class="ex">/scripts</span></a>
<a class="sourceLine" id="cb105-4" data-line-number="4">脚本内容复制执行成功的命令<span class="kw">(</span>减少每个环节出错几率<span class="kw">)</span></a>
<a class="sourceLine" id="cb105-5" data-line-number="5">脚本执行的输出信息可以重定向至其他位置保留或写入<span class="ex">/dev/null</span></a>
<a class="sourceLine" id="cb105-6" data-line-number="6"><span class="ex">3.</span>执行脚本</a>
<a class="sourceLine" id="cb105-7" data-line-number="7">使用<span class="ex">bash</span>命令执行, 防止脚本没有增加执行权限(/usr/bin/bash)</a>
<a class="sourceLine" id="cb105-8" data-line-number="8">执行脚本成功后，复制该执行的命令，以便写入<span class="ex">cron</span></a>
<a class="sourceLine" id="cb105-9" data-line-number="9"><span class="ex">4.</span>编写计划任务</a>
<a class="sourceLine" id="cb105-10" data-line-number="10">加上必要的注释信息, 人、时间、任务</a>
<a class="sourceLine" id="cb105-11" data-line-number="11">设定计划任务执行的周期</a>
<a class="sourceLine" id="cb105-12" data-line-number="12">粘贴执行脚本的命令<span class="kw">(</span>不要手敲<span class="kw">)</span></a>
<a class="sourceLine" id="cb105-13" data-line-number="13"><span class="ex">5.</span>调试计划任务(进行确认检查)</a>
<a class="sourceLine" id="cb105-14" data-line-number="14">增加任务频率测试</a>
<a class="sourceLine" id="cb105-15" data-line-number="15">检查环境变量问题</a>
<a class="sourceLine" id="cb105-16" data-line-number="16">检查<span class="ex">crond</span>服务日志</a></code></pre></div>
<h2 id="系统排查">16. 系统排查</h2>
<p><strong>我们以三个示例分别来看这三种情况，并用 stress、mpstat、pidstat 等工具，找出平均负载升高的根源。</strong> stress 是 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。 mpstat 是多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。 pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb106-1" data-line-number="1"><span class="co">#如果出现无法使用mpstat、pidstat命令查看%wait指标建议更新下软件包</span></a>
<a class="sourceLine" id="cb106-2" data-line-number="2"><span class="fu">wget</span> http://pagesperso-orange.fr/sebastien.godard/sysstat-11.7.3-1.x86_64.rpm</a>
<a class="sourceLine" id="cb106-3" data-line-number="3"><span class="ex">rpm</span> -Uvh sysstat-11.7.3-1.x86_64.rpm</a></code></pre></div>
<h3 id="cpu-密集型进程">16.1 CPU 密集型进程</h3>
<p><em>1.首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</em></p>
<div class="sourceCode" id="cb107"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb107-1" data-line-number="1">[<span class="ex">root@m01</span> ~]# stress --cpu 1 --timeout 600</a></code></pre></div>
<p><em>2.接着，在第二个终端运行 uptime 查看平均负载的变化情况</em></p>
<div class="sourceCode" id="cb108"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb108-1" data-line-number="1"><span class="co"># 使用watch -d 参数表示高亮显示变化的区域(注意负载会持续升高)</span></a>
<a class="sourceLine" id="cb108-2" data-line-number="2">[<span class="ex">root@m01</span> ~]# watch -d uptime</a>
<a class="sourceLine" id="cb108-3" data-line-number="3"><span class="ex">17</span>:27:44 up 2 days,  3:11,  3 users,  load average: 1.10, 0.30, 0.17</a></code></pre></div>
<p><em>3.最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</em></p>
<div class="sourceCode" id="cb109"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb109-1" data-line-number="1"><span class="co"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></a>
<a class="sourceLine" id="cb109-2" data-line-number="2">[<span class="ex">root@m01</span> ~]# mpstat -P ALL 5</a>
<a class="sourceLine" id="cb109-3" data-line-number="3"><span class="ex">Linux</span> 3.10.0-957.1.3.el7.x86_64 (m01)   <span class="ex">2019</span>年04月29日     _x86_64_    (1 CPU)</a>
<a class="sourceLine" id="cb109-4" data-line-number="4"></a>
<a class="sourceLine" id="cb109-5" data-line-number="5"><span class="ex">17</span>时32分03秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</a>
<a class="sourceLine" id="cb109-6" data-line-number="6"><span class="ex">17</span>时32分08秒  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</a>
<a class="sourceLine" id="cb109-7" data-line-number="7"><span class="ex">17</span>时32分08秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</a>
<a class="sourceLine" id="cb109-8" data-line-number="8"></a>
<a class="sourceLine" id="cb109-9" data-line-number="9"><span class="co">#单核CPU所以只有一个all和0</span></a></code></pre></div>
<p><em>4.从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 pidstat 来查询</em></p>
<div class="sourceCode" id="cb110"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb110-1" data-line-number="1"><span class="co"># 间隔 5 秒后输出一组数据</span></a>
<a class="sourceLine" id="cb110-2" data-line-number="2">[<span class="ex">root@m01</span> ~]# pidstat -u 5 1</a>
<a class="sourceLine" id="cb110-3" data-line-number="3"><span class="ex">Linux</span> 3.10.0-957.1.3.el7.x86_64 (m01)   <span class="ex">2019</span>年04月29日     _x86_64_(1 CPU)</a>
<a class="sourceLine" id="cb110-4" data-line-number="4"></a>
<a class="sourceLine" id="cb110-5" data-line-number="5"><span class="ex">17</span>时33分21秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</a>
<a class="sourceLine" id="cb110-6" data-line-number="6"><span class="ex">17</span>时33分26秒     0    110019   98.80    0.00    0.00   98.80     0  stress</a>
<a class="sourceLine" id="cb110-7" data-line-number="7"></a>
<a class="sourceLine" id="cb110-8" data-line-number="8"><span class="co">#从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</span></a></code></pre></div>
<h3 id="io-密集型进程">16.2 I/O 密集型进程</h3>
<p><em>1.首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync</em></p>
<div class="sourceCode" id="cb111"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb111-1" data-line-number="1">[<span class="ex">root@m01</span> ~]# stress  --io 1 --timeout 600s</a></code></pre></div>
<p><em>2.然后在第二个终端运行 uptime 查看平均负载的变化情况：</em></p>
<div class="sourceCode" id="cb112"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb112-1" data-line-number="1">[<span class="ex">root@m01</span> ~]# watch -d uptime</a>
<a class="sourceLine" id="cb112-2" data-line-number="2"><span class="ex">18</span>:43:51 up 2 days,  4:27,  3 users,  load average: 1.12, 0.65, 0.00</a></code></pre></div>
<p><em>3.最后第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</em></p>
<div class="sourceCode" id="cb113"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb113-1" data-line-number="1"><span class="co"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span></a>
<a class="sourceLine" id="cb113-2" data-line-number="2">[<span class="ex">root@m01</span> ~]# mpstat -P ALL 5</a>
<a class="sourceLine" id="cb113-3" data-line-number="3"><span class="ex">Linux</span> 3.10.0-693.2.2.el7.x86_64 (bgx.com)   <span class="ex">2019</span>年05月07日     _x86_64_    (1 CPU)</a>
<a class="sourceLine" id="cb113-4" data-line-number="4"></a>
<a class="sourceLine" id="cb113-5" data-line-number="5"><span class="ex">14</span>时20分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</a>
<a class="sourceLine" id="cb113-6" data-line-number="6"><span class="ex">14</span>时20分12秒  all    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</a>
<a class="sourceLine" id="cb113-7" data-line-number="7"><span class="ex">14</span>时20分12秒    0    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</a>
<a class="sourceLine" id="cb113-8" data-line-number="8"></a>
<a class="sourceLine" id="cb113-9" data-line-number="9"><span class="co">#会发现cpu的与内核打交道的sys占用非常高</span></a></code></pre></div>
<p><em>4.那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询</em></p>
<div class="sourceCode" id="cb114"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="co"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2">[<span class="ex">root@m01</span> ~]# pidstat -u 5 1</a>
<a class="sourceLine" id="cb114-3" data-line-number="3"><span class="ex">Linux</span> 3.10.0-957.1.3.el7.x86_64 (m01)   <span class="ex">2019</span>年04月29日     _x86_64_(1 CPU)</a>
<a class="sourceLine" id="cb114-4" data-line-number="4"><span class="ex">18</span>时29分37秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</a>
<a class="sourceLine" id="cb114-5" data-line-number="5"><span class="ex">18</span>时29分42秒     0    127259   32.60    0.20    0.00   67.20   32.80     0  stress</a>
<a class="sourceLine" id="cb114-6" data-line-number="6"><span class="ex">18</span>时29分42秒     0    127261    4.60   28.20    0.00   67.20   32.80     0  stress</a>
<a class="sourceLine" id="cb114-7" data-line-number="7"><span class="ex">18</span>时29分42秒     0    127262    4.20   28.60    0.00   67.20   32.80     0  stress</a>
<a class="sourceLine" id="cb114-8" data-line-number="8"></a>
<a class="sourceLine" id="cb114-9" data-line-number="9"><span class="co">#可以发现，还是 stress 进程导致的。</span></a></code></pre></div>
<h3 id="大量进程场景">16.3 大量进程场景</h3>
<p><em>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</em></p>
<p><em>1.首先，我们还是使用 stress，但这次模拟的是 4 个进程</em></p>
<div class="sourceCode" id="cb115"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb115-1" data-line-number="1">[<span class="ex">root@m01</span> ~]# stress -c 4 --timeout 600</a></code></pre></div>
<p><em>2.由于系统只有 1 个 CPU，明显比 4 个进程要少得多，因而，系统的 CPU 处于严重过载状态</em></p>
<div class="sourceCode" id="cb116"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb116-1" data-line-number="1">[<span class="ex">root@m01</span> ~]# watch -d uptime</a>
<a class="sourceLine" id="cb116-2" data-line-number="2"><span class="ex">19</span>:11:07 up 2 days,  4:45,  3 users,  load average: 4.65, 2.65, 4.65</a></code></pre></div>
<p><em>3.然后，再运行 pidstat 来看一下进程的情况：</em></p>
<div class="sourceCode" id="cb117"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb117-1" data-line-number="1"><span class="co"># 间隔 5 秒后输出一组数据</span></a>
<a class="sourceLine" id="cb117-2" data-line-number="2">[<span class="ex">root@m01</span> ~]# pidstat -u 5 1</a>
<a class="sourceLine" id="cb117-3" data-line-number="3">平均时间:   <span class="ex">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</a>
<a class="sourceLine" id="cb117-4" data-line-number="4">平均时间:     <span class="ex">0</span>    130290   24.55    0.00    0.00   75.25   24.55     -  stress</a>
<a class="sourceLine" id="cb117-5" data-line-number="5">平均时间:     <span class="ex">0</span>    130291   24.95    0.00    0.00   75.25   24.95     -  stress</a>
<a class="sourceLine" id="cb117-6" data-line-number="6">平均时间:     <span class="ex">0</span>    130292   24.95    0.00    0.00   75.25   24.95     -  stress</a>
<a class="sourceLine" id="cb117-7" data-line-number="7">平均时间:     <span class="ex">0</span>    130293   24.75    0.00    0.00   74.65   24.75     -  stress</a></code></pre></div>
<p><em>可以看出，4 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</em></p>
<h4 id="总结">总结</h4>
<p>https://www.cnblogs.com/muahao/p/6346775.html</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb118-1" data-line-number="1">平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</a>
<a class="sourceLine" id="cb118-2" data-line-number="2">平均负载高有可能是 <span class="ex">CPU</span> 密集型进程导致的；</a>
<a class="sourceLine" id="cb118-3" data-line-number="3">平均负载高并不一定代表 <span class="ex">CPU</span> 使用率高，还有可能是 I/O 更繁忙了；</a>
<a class="sourceLine" id="cb118-4" data-line-number="4">当发现负载高的时候，你可以使用 <span class="ex">mpstat</span>、pidstat 等工具，辅助分析负载的来源</a></code></pre></div>
<h2 id="systemctl-系统管理">17. systemctl 系统管理</h2>
<p><strong>systemd相关配置文件</strong></p>
<pre><code>/usr/lib/systemd/system/    #类似Centos6系统的启动脚本，/etc/init.d/
/etc/systemd/system/        #类似Centos6系统的/etc/rc.d/rcN.d/
/etc/systemd/system/multi-user.target.wants/</code></pre>
<p><strong>systemd管理服务相关命令</strong> systemctl管理服务的启动、重启、停止、重载、查看状态等常用命令 针对当前正在运行的程 序</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">systemctl命令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">systemctl start crond.service</td>
<td style="text-align: left;">启动服务</td>
</tr>
<tr class="even">
<td style="text-align: left;">systemctl stop crond.service</td>
<td style="text-align: left;">停止服务</td>
</tr>
<tr class="odd">
<td style="text-align: left;">systemctl restart crond.service</td>
<td style="text-align: left;">重启服务</td>
</tr>
<tr class="even">
<td style="text-align: left;">systemctl reload crond.service</td>
<td style="text-align: left;">重新加载配置</td>
</tr>
<tr class="odd">
<td style="text-align: left;">systemctl status crond.servre</td>
<td style="text-align: left;">查看服务运行状态</td>
</tr>
<tr class="even">
<td style="text-align: left;">systemctl is-active sshd.service</td>
<td style="text-align: left;">查看服务是否在运行中</td>
</tr>
<tr class="odd">
<td style="text-align: left;">systemctl mask crond.servre</td>
<td style="text-align: left;">禁止服务运行</td>
</tr>
<tr class="even">
<td style="text-align: left;">systemctl unmask crond.servre</td>
<td style="text-align: left;">取消禁止服务运行</td>
</tr>
</tbody>
</table>
<p><strong>当我们使用systemctl启动一个守护进程后，可以通过sysctemctl status查看此守护进程的状态</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">状态</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">loaded</td>
<td style="text-align: left;">服务单元的配置文件已经被处理</td>
</tr>
<tr class="even">
<td style="text-align: left;">active(running)</td>
<td style="text-align: left;">服务持续运行</td>
</tr>
<tr class="odd">
<td style="text-align: left;">active(exited)</td>
<td style="text-align: left;">服务成功完成一次的配置</td>
</tr>
<tr class="even">
<td style="text-align: left;">active(waiting)</td>
<td style="text-align: left;">服务已经运行但在等待某个事件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">inactive</td>
<td style="text-align: left;">服务没有在运行</td>
</tr>
<tr class="even">
<td style="text-align: left;">enabled</td>
<td style="text-align: left;">服务设定为开机运行</td>
</tr>
<tr class="odd">
<td style="text-align: left;">disabled</td>
<td style="text-align: left;">服务设定为开机不运行</td>
</tr>
<tr class="even">
<td style="text-align: left;">static</td>
<td style="text-align: left;">服务开机不启动，但可以被其他服务调用启动</td>
</tr>
</tbody>
</table>
<p><strong>systemctl 设置服务开机启动、不启动、查看各级别下服务启动状态等常用命令</strong></p>
<div class="sourceCode" id="cb120"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb120-1" data-line-number="1"><span class="ex">systemctl</span>命令（7系统）                        作用</a>
<a class="sourceLine" id="cb120-2" data-line-number="2"></a>
<a class="sourceLine" id="cb120-3" data-line-number="3"><span class="ex">systemctl</span> enable crond.service              开机自动启动</a>
<a class="sourceLine" id="cb120-4" data-line-number="4"><span class="ex">systemctl</span> disable crond.service             开机不自动启动</a>
<a class="sourceLine" id="cb120-5" data-line-number="5"><span class="ex">systemctl</span> list-unit-files                   查看各个级别下服务的启动与禁用</a>
<a class="sourceLine" id="cb120-6" data-line-number="6"><span class="ex">systemctl</span> is-enabled crond.service          查看特定服务是否为开机自启动</a>
<a class="sourceLine" id="cb120-7" data-line-number="7"><span class="ex">systemctl</span> daemon-reload                     创建新服务文件需要重载变更(更改服务后要启动不成功时会提示执行这个命令)</a></code></pre></div>
<p><strong>systemctl的journalctl日志</strong></p>
<pre><code>journalctl -n 20    #查看最后20行
journalctl -f       #动态查看日志
journalctl -p err   #查看日志的级别
journalctl -u crond #查看某个服务的单元的日志</code></pre>
<h1 id="linux基础知识">Linux基础知识</h1>
<h2 id="linux目录结构">0.linux目录结构</h2>
<div class="sourceCode" id="cb122"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb122-1" data-line-number="1">[<span class="ex">root@wyk</span> ~]# ll /</a>
<a class="sourceLine" id="cb122-2" data-line-number="2"><span class="ex">usr</span>                             系统文件目录相当于c:\windows</a>
<a class="sourceLine" id="cb122-3" data-line-number="3"><span class="ex">lib</span> -<span class="op">&gt;</span> usr/lib                  库文件Glibc 32bit  汽车的螺丝           </a>
<a class="sourceLine" id="cb122-4" data-line-number="4"><span class="ex">lib64</span> -<span class="op">&gt;</span> usr/lib64              库文件Glibc 64bit  汽车的螺丝   </a>
<a class="sourceLine" id="cb122-5" data-line-number="5"><span class="ex">sbin</span> -<span class="op">&gt;</span> usr/sbin                管理员使用的命令    /sbin/shutdown, /sbin/reboot</a>
<a class="sourceLine" id="cb122-6" data-line-number="6"><span class="ex">bin</span> -<span class="op">&gt;</span> usr/bin                  普通用户使用的命令   /bin/ls, /bin/date </a>
<a class="sourceLine" id="cb122-7" data-line-number="7"><span class="ex">boot</span>                            存放系统启动相关的文件, 例如:kernel, grub(引导装载程序)</a>
<a class="sourceLine" id="cb122-8" data-line-number="8">                                <span class="ex">grub</span>（ 告诉你 有哪些内核，你可以选择需要加载的那一个）</a>
<a class="sourceLine" id="cb122-9" data-line-number="9">                                <span class="ex">vmlinuz-3.10.0-957.12.2.el7.x86_64</span>  正常的系统内核</a>
<a class="sourceLine" id="cb122-10" data-line-number="10">                                <span class="ex">vmlinuz-0-rescue-93f219319dd5bdb4xx</span> 统的救援内核</a>
<a class="sourceLine" id="cb122-11" data-line-number="11"><span class="ex">etc</span>                             系统配置文件</a>
<a class="sourceLine" id="cb122-12" data-line-number="12"><span class="ex">home</span>                            普通用户家目录</a>
<a class="sourceLine" id="cb122-13" data-line-number="13"><span class="ex">root</span>                            系统管理员家目录</a>
<a class="sourceLine" id="cb122-14" data-line-number="14"><span class="ex">proc</span>                            进程文件</a>
<a class="sourceLine" id="cb122-15" data-line-number="15"><span class="ex">tmp</span>                             临时目录</a>
<a class="sourceLine" id="cb122-16" data-line-number="16"><span class="ex">var</span>                             日志文件</a>
<a class="sourceLine" id="cb122-17" data-line-number="17"><span class="ex">/var/tmp</span>                        进程产生的临时文件</a>
<a class="sourceLine" id="cb122-18" data-line-number="18"><span class="ex">dev</span>                             设备目录文件(硬盘\光驱等等)</a>
<a class="sourceLine" id="cb122-19" data-line-number="19"><span class="ex">/dev</span>                            存放设备文件,比如硬盘,硬盘分区,光驱,等等</a>
<a class="sourceLine" id="cb122-20" data-line-number="20"><span class="ex">/dev/null</span>                       黑洞设备,只进不出.类似于垃圾回收站</a>
<a class="sourceLine" id="cb122-21" data-line-number="21"><span class="ex">/dev/random</span>                     生成随机数设备</a>
<a class="sourceLine" id="cb122-22" data-line-number="22"><span class="ex">/dev/zero</span>                       能源源不断的产生数据,类似于取款机,随时随地取钱</a>
<a class="sourceLine" id="cb122-23" data-line-number="23"></a>
<a class="sourceLine" id="cb122-24" data-line-number="24"><span class="ex">--------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb122-25" data-line-number="25"><span class="ex">media</span>                           挂载我们的u盘、或者其他设备</a>
<a class="sourceLine" id="cb122-26" data-line-number="26"><span class="ex">mnt</span>                             挂载我们的u盘、或者其他设备</a>
<a class="sourceLine" id="cb122-27" data-line-number="27"><span class="ex">opt</span>                             三方厂商包目录oracle  gitlab</a>
<a class="sourceLine" id="cb122-28" data-line-number="28"><span class="ex">run</span>                             包含系统运行时所需要的文件。以前 /var/run</a>
<a class="sourceLine" id="cb122-29" data-line-number="29"><span class="ex">srv</span>                             服务启动后需要访问的数据目录。使用很少<span class="kw">|</span> <span class="ex">saltstack</span></a>
<a class="sourceLine" id="cb122-30" data-line-number="30"><span class="ex">sys</span>                             sys和proc一样是虚拟文件系统，记录核心系统硬件信息。</a></code></pre></div>
<h2 id="文件属性类型">1.文件属性类型</h2>
<p>1.1.文件属性</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb123-1" data-line-number="1">整个文件的属性分为十列</a>
<a class="sourceLine" id="cb123-2" data-line-number="2"><span class="co">#ls -l</span></a>
<a class="sourceLine" id="cb123-3" data-line-number="3"><span class="ex">-rw-r--r--</span> 1 root root 1019 Apr 28 15:41 pass.txt</a>
<a class="sourceLine" id="cb123-4" data-line-number="4"></a>
<a class="sourceLine" id="cb123-5" data-line-number="5"><span class="ex">-</span>                   1：文件类型              </a>
<a class="sourceLine" id="cb123-6" data-line-number="6"><span class="ex">rw-r--r--</span>           2：权限    </a>
<a class="sourceLine" id="cb123-7" data-line-number="7"><span class="ex">1</span>                   3：表示硬链接数                </a>
<a class="sourceLine" id="cb123-8" data-line-number="8"><span class="ex">root</span>                4：这个文件的拥有人是谁       （个人）</a>
<a class="sourceLine" id="cb123-9" data-line-number="9"><span class="ex">root</span>                5：这个文件的拥有组是谁       （小组）</a>
<a class="sourceLine" id="cb123-10" data-line-number="10"><span class="ex">1019</span>                6：文件大小</a>
<a class="sourceLine" id="cb123-11" data-line-number="11"><span class="ex">Apr</span> 28 15:41        7、8、9：文件创建或修改的时间</a>
<a class="sourceLine" id="cb123-12" data-line-number="12"><span class="ex">pass.txt</span>            10:文件的名称</a></code></pre></div>
<p>1.2.文件类型</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb124-1" data-line-number="1">使用<span class="ex">ll</span> 或者 ls -l 能够区分出来的效果</a>
<a class="sourceLine" id="cb124-2" data-line-number="2"><span class="ex">-</span>:  表示是一个文件( 普通文件、脚本文件、压缩文件、命令文件)</a>
<a class="sourceLine" id="cb124-3" data-line-number="3"><span class="ex">s</span>:  socket,进程与进程之间的通讯协议</a>
<a class="sourceLine" id="cb124-4" data-line-number="4"><span class="ex">c</span>:  字符设备（终端、键盘）</a>
<a class="sourceLine" id="cb124-5" data-line-number="5"><span class="ex">b</span>:  块设备（磁盘）</a>
<a class="sourceLine" id="cb124-6" data-line-number="6"><span class="ex">l</span>:  软链接（快捷方式）</a>
<a class="sourceLine" id="cb124-7" data-line-number="7"><span class="ex">d</span>:  表示一个目录</a></code></pre></div>
<p>1.3.file 判断文件类型</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb125-1" data-line-number="1">我们无法通过<span class="ex">ls</span> -l文件的类型，比如一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用file来更加精准的判断这个文件的类型</a>
<a class="sourceLine" id="cb125-2" data-line-number="2"></a>
<a class="sourceLine" id="cb125-3" data-line-number="3"><span class="ex">file</span>命令判断最准确</a>
<a class="sourceLine" id="cb125-4" data-line-number="4">通过后缀判断文件类型 <span class="ex">mp4</span> sh zip txt log........</a></code></pre></div>
<h2 id="用户组管理">2.用户、组管理</h2>
<p><strong>1.用户管理</strong></p>
<p><strong>/etc/passwd</strong>,记录了用户的信息 <strong>/etc/shadow</strong> 记录了用户的密码</p>
<pre><code># head -n1 /etc/passwd
root:x:0:0:root:/root:/bin/bash         #以:作为分隔符,总共七列
  1  2 3 4  5      6      7
分别为：
用户名称:密码占位符:用户UID:组GID:注释信息:用户家目录:登录shell</code></pre>
<p><strong>系统对用户有一个约定</strong></p>
<table>
<thead>
<tr class="header">
<th>用户UID</th>
<th>系统中约定的含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>超级管理,最高权限,有着极强的破坏力</td>
</tr>
<tr class="even">
<td>1~200</td>
<td>系统用户,用来运行系统自带的进程,默认已创建</td>
</tr>
<tr class="odd">
<td>201~999</td>
<td>系统用户,用来运行用户安装的程序,所有此类用户无需登录系统</td>
</tr>
<tr class="even">
<td>1000+</td>
<td>普通用户,正常可以登录系统用户,权限比较小,能执行的任务有限</td>
</tr>
</tbody>
</table>
<p><strong>用户创建流程</strong></p>
<pre class="shell"><code>#useradd创建用户时，系统会以/etc/login.defs、/etc/default/useradd 两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖etc/login.defs、/etc/default/useradd文件默认配置，如未指定则使用默认。

[root@test01 ~]# grep -E -v &quot;^#|^$&quot; /etc/login.defs 
MAIL_DIR        /var/spool/mail         创建邮箱的位置
PASS_MAX_DAYS   99999                   密码最长使用的天数
PASS_MIN_DAYS   0                       密码最短使用的天数
PASS_MIN_LEN    5                       密码长度
PASS_WARN_AGE   7                       密码到期前7天警告
UID_MIN                  1000           用户uid最小值
UID_MAX                 60000           用户uid最大值
SYS_UID_MIN               201           系统uid最小值
SYS_UID_MAX               999           系统uid最大值
GID_MIN                  1000           组id最小值
GID_MAX                 60000           组id最大值
SYS_GID_MIN               201           系统GID最大值
SYS_GID_MAX               999           系统GID最大值
CREATE_HOME yes                         是否创建加目录开关
UMASK           077                     权限位
USERGROUPS_ENAB yes                     创建用户默认组开关
ENCRYPT_METHOD SHA512                   密码加密算法

[root@test01 ~]# cat /etc/default/useradd 
# useradd defaults file
GROUP=100                   关闭默认创建组开关后，默认分配GID100的组
HOME=/home                  默认家目录
INACTIVE=-1                 用户失效时间，-1永久不失效
EXPIRE=                     过期时间
SHELL=/bin/bash             默认登录shell
SKEL=/etc/skel              默认用户拷贝的环境变量（命令提示符）
CREATE_MAIL_SPOOL=yes       是否开启邮箱开关
</code></pre>
<p><strong>2.组管理</strong></p>
<pre><code>基本组：创建时指定组，就叫基本组，创建时可通过-g指定，如未指定则创建一个默认的组与用户同名  （只能有1个）
私有组：创建时没有指定组，默认创建与用户同名的组        （只有有1个）
附加组：基本组如果无法满足授权要求，可以将用户加入有权限的附加组，用户顺势继承该组的权限。当然附加组可以（有N多个)

   ps:
        1.首先得有组。
        2.在进行加入。</code></pre>
<table>
<thead>
<tr class="header">
<th>用户UID</th>
<th>系统中约定的含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>超级管理员，最高权限，有着极强的破坏能力</td>
</tr>
<tr class="even">
<td>1~200</td>
<td>系统用户，用来运行系统自带的进程，默认已创建</td>
</tr>
<tr class="odd">
<td>201~999</td>
<td>系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td>
</tr>
<tr class="even">
<td>1000+</td>
<td>普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td>
</tr>
</tbody>
</table>
<h2 id="文件权限管理">3. 文件权限管理</h2>
<p>1、权限中的rwx是干什么的</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">字母</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">对应权限</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">r(read)</td>
<td style="text-align: left;">读取权限</td>
<td style="text-align: left;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;">w(write)</td>
<td style="text-align: left;">写入权限</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x(execute)</td>
<td style="text-align: left;">执行权限</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">-(没有权限)</td>
<td style="text-align: left;">没有权限</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
<p>2、<strong>权限中的rwx对文件的影响：</strong></p>
<pre><code>读取权限（r）具有读取\阅读文件内容权限
1.只能使用查看类命令cat、head、tail、less、more

写入权限（w）具有新增、修改文件内容的权限
1.使用vim编辑会提示权限拒绝, 但可强制保存,会覆盖文件的所有内容
2.使用echo命令重定向的方式可以往文件内写入数据,  &gt;&gt;可以进行追加
3.不能删除文件,因为删除文件看的不是文件的属性,  需要看上级目录是否有w的权限

执行权限（x）具有执行文件的权限
1.执行权限什么用都没有
2.如果普通用户需要执行文件,需要配合r权限   rx （命令）  rw（配置文件） r(单纯的普通只看不改不执行)</code></pre>
<p>3、<strong>rwx对目录的影响</strong></p>
<pre><code>读取权限（r），如果目录只有r权限: 具有浏览目录及子目录权限
    1.可以使用ls命令浏览目录及子目录， 但同时也会提示权限拒绝
    2.使用ls -l命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名
    总结: 目录只有r权限，仅仅只能浏览内的文件名，无其他操作权限

写入权限（w），如果目录只有w权限: 具有增加、删除或修改目录内文件名权限(需要x权限配合)
    PS: 如果目录有w权限, 可以在目录内创建文件, 删除文件(跟文件本身权限无关)
    不能进入目录、不能复制目录、不能删除目录、不能移动目录

执行权限（x），如果目录只有x权限
    1.只能进入目录
    2.不能浏览、复制、移动、删除</code></pre>
<p>总结</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb131-1" data-line-number="1">目录： 给予<span class="ex">rx</span></a>
<a class="sourceLine" id="cb131-2" data-line-number="2"><span class="ex">1.</span>拥有进入该目录的权限</a>
<a class="sourceLine" id="cb131-3" data-line-number="3"><span class="ex">2.</span>如果想操作该目录下文件，那么就取决于该文件是否允许对应的用户进行操作</a>
<a class="sourceLine" id="cb131-4" data-line-number="4"><span class="ex">3.</span>无法对该目录进行新增和删除文件</a>
<a class="sourceLine" id="cb131-5" data-line-number="5"></a>
<a class="sourceLine" id="cb131-6" data-line-number="6"><span class="ex">rx</span>  目录  </a>
<a class="sourceLine" id="cb131-7" data-line-number="7">    <span class="ex">rw</span>  文件（配置）</a>
<a class="sourceLine" id="cb131-8" data-line-number="8">    <span class="ex">rx</span>  文件（脚本）</a>
<a class="sourceLine" id="cb131-9" data-line-number="9">    <span class="ex">r</span>   文件（重要的文件，只能看，不能改，也不能执行。）</a>
<a class="sourceLine" id="cb131-10" data-line-number="10">    </a>
<a class="sourceLine" id="cb131-11" data-line-number="11"><span class="ex">PS</span>: 文件的 x权限小心给予，目录的 w权限小心给予。</a>
<a class="sourceLine" id="cb131-12" data-line-number="12"><span class="ex">PS</span>: 文件通常设定的权限是644,目录设定的权限是755</a>
<a class="sourceLine" id="cb131-13" data-line-number="13"><span class="ex">PS</span>: 控制目录权限755, 如果有普通用户需要操作目录里面的文件，在来看文件的权限</a></code></pre></div>
<h2 id="输入输出">4. 输入输出</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">文件描述符</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">标准输入（STDIN）</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">默认是键盘，也可以是文件或其他命令的输出。</td>
</tr>
<tr class="even">
<td style="text-align: left;">标准输出（STDOUT）</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">默认输出到屏幕。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">错误输出（STDERR）</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">默认输出到屏幕。</td>
</tr>
<tr class="even">
<td style="text-align: left;">文件名称（filename）</td>
<td style="text-align: left;">3+….</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p><strong>输出重定向，改变输出内容的位置。输出重定向有如下几种方式，如表格所示</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">类型</th>
<th style="text-align: left;">操作符</th>
<th style="text-align: left;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">标准覆盖输出重定向</td>
<td style="text-align: left;">&gt;</td>
<td style="text-align: left;">将程序输出的正确结果输出到指定的文件中,会覆盖文件原有的内容</td>
</tr>
<tr class="even">
<td style="text-align: left;">标准追加输出重定向</td>
<td style="text-align: left;">&gt;&gt;</td>
<td style="text-align: left;">将程序输出的正确结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">错误覆盖输出重定向</td>
<td style="text-align: left;">2&gt;</td>
<td style="text-align: left;">将程序的错误结果输出到执行的文件中，会覆盖文件原有的内容</td>
</tr>
<tr class="even">
<td style="text-align: left;">错误追加输出重定向</td>
<td style="text-align: left;">2&gt;&gt;</td>
<td style="text-align: left;">将程序输出的错误结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">标准输入重定向</td>
<td style="text-align: left;">&lt;&lt;</td>
<td style="text-align: left;">将命令中接收输入的途径由默认的键盘更改为指定的文件或命令</td>
</tr>
</tbody>
</table>
<h2 id="yum包管理-1">5. yum包管理</h2>
<p><strong>一个repo文件内容</strong></p>
<div class="sourceCode" id="cb132"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb132-1" data-line-number="1">[<span class="ex">root@container</span> ~]# cat /etc/yum.repos.d/test.repo</a>
<a class="sourceLine" id="cb132-2" data-line-number="2">[<span class="ex">local-oldboy</span>]              #仓库名称，可随意表示</a>
<a class="sourceLine" id="cb132-3" data-line-number="3"><span class="ex">name</span> = Local Packages       #仓库的描述 可通过 yum repolist查看</a>
<a class="sourceLine" id="cb132-4" data-line-number="4"><span class="ex">baseurl</span> = file:///mnt       #我们的仓库在那里，使用什么协议访问有http:// ftp://  file://</a>
<a class="sourceLine" id="cb132-5" data-line-number="5"><span class="ex">enabled</span> = 1                 #是否启用该仓库   1 表示启动  0表示不启用</a>
<a class="sourceLine" id="cb132-6" data-line-number="6"><span class="ex">gpgcheck</span> = 0                #是否要校验软件包的合法性  （ 0 不校验 ）</a></code></pre></div>
<h2 id="磁盘管理-1">6. 磁盘管理</h2>
<p>远程控制卡操作参考链接 https://www.bilibili.com/video/av46656120/?p=7</p>
<p><strong>1.如何使用磁盘</strong></p>
<div class="sourceCode" id="cb133"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb133-1" data-line-number="1"><span class="ex">1.1</span> 有一个磁盘</a>
<a class="sourceLine" id="cb133-2" data-line-number="2"><span class="ex">1.2</span> 使用fdisk分区  大于2tb 使用 gdisk分区   （分一个区，或者直接使用整个磁盘）</a>
<a class="sourceLine" id="cb133-3" data-line-number="3"><span class="ex">1.3</span> 需要进行格式化   mkfs.xfs</a>
<a class="sourceLine" id="cb133-4" data-line-number="4"><span class="ex">1.4</span> 使用mount进行挂载</a>
<a class="sourceLine" id="cb133-5" data-line-number="5"><span class="ex">1.5</span> 将挂载的信息添加到/etc/fstab  </a>
<a class="sourceLine" id="cb133-6" data-line-number="6"><span class="ex">1.6</span> 使用 mount -a 执行没有任何错误，代表编写正常。重启设备会自动挂载上来</a></code></pre></div>
<p><strong>2.SWAP</strong></p>
<div class="sourceCode" id="cb134"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb134-1" data-line-number="1"><span class="ex">2.1</span> SWAP是当物理内存不够时，临时将磁盘空间作为内存顶替使用</a>
<a class="sourceLine" id="cb134-2" data-line-number="2"><span class="ex">2.2</span> 如果没有swap 物理不够，系统会启用保护机制，然后kill掉某个占用内存的程序</a>
<a class="sourceLine" id="cb134-3" data-line-number="3"><span class="ex">2.3</span> 如果有swap，物理不够，会使用swap作为内存（系统就会开始变得比较的卡顿了）</a>
<a class="sourceLine" id="cb134-4" data-line-number="4"><span class="ex">16Gb</span>    <span class="kw">|</span> 云主机 基本没有<span class="ex">swap</span></a></code></pre></div>
<p><strong>3.RAID</strong></p>
<div class="sourceCode" id="cb135"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb135-1" data-line-number="1"><span class="ex">3.1</span> 磁盘阵列技术，对磁盘进行编排，提供更高的读写速度、以及冗余能力。</a>
<a class="sourceLine" id="cb135-2" data-line-number="2"><span class="ex">3.2</span> RAID 0   1  5  10 </a>
<a class="sourceLine" id="cb135-3" data-line-number="3"><span class="ex">3.3</span> RAID 0 快、大。   坏一个磁盘，都结束了。</a>
<a class="sourceLine" id="cb135-4" data-line-number="4"><span class="ex">3.4</span> RAID 1 有冗余，允许坏一个盘、写不快，读比较快。 容量仅能使用 百分之 50%</a>
<a class="sourceLine" id="cb135-5" data-line-number="5"><span class="ex">3.5</span> RAID 5 既能保证速度、还能保证冗余、空间有1/3的浪费。  成本可控。   （ 使用较多 ）</a>
<a class="sourceLine" id="cb135-6" data-line-number="6"><span class="ex">3.6</span> RAID 10   先做RAID 1  在做RAID0  （做2个RAID1 4快盘，==<span class="op">&gt;</span>RAID0  空间 50% ）</a>
<a class="sourceLine" id="cb135-7" data-line-number="7"></a>
<a class="sourceLine" id="cb135-8" data-line-number="8">冗余从好到坏：<span class="va">Raid1=</span>=<span class="op">&gt;</span><span class="va">Raid10=</span>=<span class="op">&gt;</span><span class="va">Raid5=</span>=<span class="op">&gt;</span><span class="ex">Raid0</span></a>
<a class="sourceLine" id="cb135-9" data-line-number="9">性能从好到坏：<span class="va">Raid0=</span>=<span class="op">&gt;</span><span class="va">Raid10=</span>=<span class="op">&gt;</span><span class="va">Raid5=</span>=<span class="op">&gt;</span><span class="ex">Raid1</span></a>
<a class="sourceLine" id="cb135-10" data-line-number="10">成本从低到高：<span class="va">Raid0=</span>=<span class="op">&gt;</span><span class="va">Raid5=</span>=<span class="op">&gt;</span><span class="va">Raid1=</span>=<span class="op">&gt;</span><span class="ex">Raid10</span></a></code></pre></div>
<h2 id="systemctl系统服务管理">7. systemctl系统服务管理</h2>
<p><strong>7.1 开机启动流程</strong></p>
<ol type="1">
<li>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</li>
</ol>
<ul>
<li><p>内核的引导。</p></li>
<li><p>运行 init(6)。 sentos7 运行父进程(systemd) pstree进行查看父进程systemd -sp展开查看</p></li>
<li><p>系统初始化。</p></li>
<li><p>建立终端 。</p></li>
<li><p>用户登录系统。</p>
<p>centos7 6和7启动的祖宗进程不一样,加载初始化脚本的位置也不一样,其他都一样</p></li>
</ul>
<p><strong>7.2 运行级别</strong></p>
<p>什么是运行级别，运行级别就是操作系统当前正在运行的功能级别(一般用3命令行)</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb136-1" data-line-number="1"> <span class="ex">System</span> V init运行级别          systemd目标名称                     作用</a>
<a class="sourceLine" id="cb136-2" data-line-number="2">  <span class="ex">0</span>                     runlevel0.target, poweroff.target           关机</a>
<a class="sourceLine" id="cb136-3" data-line-number="3">  <span class="ex">1</span>                     runlevel1.target, rescue.target             单用户模式</a>
<a class="sourceLine" id="cb136-4" data-line-number="4">  <span class="ex">2</span>                     runlevel2.target, multi-user.target         没有使用</a>
<a class="sourceLine" id="cb136-5" data-line-number="5">  <span class="ex">3</span>                     runlevel3.target, multi-user.target         多用户的文本界面</a>
<a class="sourceLine" id="cb136-6" data-line-number="6">  <span class="ex">4</span>                     runlevel4.target, multi-user.target         没有使用</a>
<a class="sourceLine" id="cb136-7" data-line-number="7">  <span class="ex">5</span>                     runlevel5.target, graphical.target          多用户的图形界面</a>
<a class="sourceLine" id="cb136-8" data-line-number="8">  <span class="ex">6</span>                     runlevel6.target, reboot.target             重启</a></code></pre></div>
<p>查看运行级别</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb137-1" data-line-number="1"><span class="co">#centos6系统的运行级别，/etc/inittab #运行级别文件,修改下面数字就可以</span></a>
<a class="sourceLine" id="cb137-2" data-line-number="2"><span class="ex">1.</span>临时</a>
<a class="sourceLine" id="cb137-3" data-line-number="3">    <span class="ex">runlevel</span>    查看当前级别   </a>
<a class="sourceLine" id="cb137-4" data-line-number="4"></a>
<a class="sourceLine" id="cb137-5" data-line-number="5">    <span class="ex">init</span> Number(级别数字)   切换级别</a>
<a class="sourceLine" id="cb137-6" data-line-number="6"></a>
<a class="sourceLine" id="cb137-7" data-line-number="7"><span class="ex">2.</span>永久  /etc/inittab</a>
<a class="sourceLine" id="cb137-8" data-line-number="8">    <span class="ex">id</span>:5:initdefault <span class="co">#开机启动什么级别(5就是图形化界面)</span></a>
<a class="sourceLine" id="cb137-9" data-line-number="9"></a>
<a class="sourceLine" id="cb137-10" data-line-number="10"><span class="co">#centos7运行级别</span></a>
<a class="sourceLine" id="cb137-11" data-line-number="11"><span class="ex">multi-user.target</span>: analogous to runlevel 3</a>
<a class="sourceLine" id="cb137-12" data-line-number="12"><span class="ex">graphical.target</span>: analogous to runlevel 5</a>
<a class="sourceLine" id="cb137-13" data-line-number="13"></a>
<a class="sourceLine" id="cb137-14" data-line-number="14"><span class="co">#systemctl get-default    查看运行级别</span></a>
<a class="sourceLine" id="cb137-15" data-line-number="15"><span class="ex">multi-user.target</span>   3</a>
<a class="sourceLine" id="cb137-16" data-line-number="16"></a>
<a class="sourceLine" id="cb137-17" data-line-number="17"><span class="co">#修改默认运行级别</span></a>
<a class="sourceLine" id="cb137-18" data-line-number="18">[<span class="ex">root@syc</span>~]# systemctl set-default graphical.target</a>
<a class="sourceLine" id="cb137-19" data-line-number="19"><span class="ex">Removed</span> symlink /etc/systemd/system/default.target.</a>
<a class="sourceLine" id="cb137-20" data-line-number="20"><span class="ex">Created</span> symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/graphical.target.</a>
<a class="sourceLine" id="cb137-21" data-line-number="21"><span class="co">#进行查看级别</span></a>
<a class="sourceLine" id="cb137-22" data-line-number="22">[<span class="ex">root@syc</span>~]# systemctl get-default</a>
<a class="sourceLine" id="cb137-23" data-line-number="23"><span class="ex">graphical.target</span></a></code></pre></div>
<h2 id="系统平均负载">8.系统平均负载</h2>
<p>每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb138-1" data-line-number="1">[<span class="ex">root@m01</span> ~]# uptime</a>
<a class="sourceLine" id="cb138-2" data-line-number="2"><span class="ex">04</span>:49:26 up 2 days, 2:33, 2 users, load average: 0.70, 0.04, 0.05</a>
<a class="sourceLine" id="cb138-3" data-line-number="3"></a>
<a class="sourceLine" id="cb138-4" data-line-number="4"><span class="co">#我们已经比较熟悉前面几列，它们分别是当前时间、系统运行时间以及正在登录用户数。</span></a>
<a class="sourceLine" id="cb138-5" data-line-number="5">而最后三个数字呢，依次则是过去 <span class="ex">1</span> 分钟、5 分钟、15 分钟的平均负载（Load Average）。</a></code></pre></div>
<p><strong>8.1 什么是平均负载</strong></p>
<ul>
<li>平均负载是指单位时间内，系统处于 可运行状态R 和 不可中断状态D 的平均进程数，也就是平均活跃进程数</li>
<li>平均负载其实就是单位时间内的活跃进程数。 ( 可运行状态R + 不可中断状态D )</li>
<li>平均负载要看的是三个值(1,5,15分钟)，不是一个。</li>
</ul>
<p><strong>8.2 可运行状态和不可中断状态是什么</strong></p>
<ul>
<li>1.可运行状态进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们ps 命令看到处于 R 状态的进程。</li>
<li>2.不可中断进程，(你做什么事情的时候是不能打断的?) 系统中最常见的是等待硬件设备的 I/O 响应，也就是我们 ps 命令中看到的 D 状态（也称为 Disk Sleep）的进程。</li>
</ul>
<p><strong>8.3 平均负载多少时合理</strong></p>
<p>最理想的状态是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。所以在评判平均负载时，首先你要知道系统有几个 CPU，这可以通过 top 命令获取，或grep ‘model name’ /proc/cpuinfo</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb139-1" data-line-number="1">例<span class="ex">1</span>、假设现在在 4、2、1核的CPU上，如果平均负载为 2 时，意味着什么呢？</a>
<a class="sourceLine" id="cb139-2" data-line-number="2"><span class="ex">Q1.</span>在4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</a>
<a class="sourceLine" id="cb139-3" data-line-number="3"><span class="ex">Q2.</span>在2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</a>
<a class="sourceLine" id="cb139-4" data-line-number="4"><span class="ex">Q3.</span>而1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</a>
<a class="sourceLine" id="cb139-5" data-line-number="5"></a>
<a class="sourceLine" id="cb139-6" data-line-number="6"></a>
<a class="sourceLine" id="cb139-7" data-line-number="7"><span class="ex">1.</span>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</a>
<a class="sourceLine" id="cb139-8" data-line-number="8"><span class="ex">2.</span>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</a>
<a class="sourceLine" id="cb139-9" data-line-number="9"><span class="ex">3.</span>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续上升，所以就需要持续观察。</a>
<a class="sourceLine" id="cb139-10" data-line-number="10"></a>
<a class="sourceLine" id="cb139-11" data-line-number="11"><span class="ex">PS</span>: 一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析问题，并要想办法优化了</a>
<a class="sourceLine" id="cb139-12" data-line-number="12">在来看个例子<span class="ex">3</span>、假设我们在有2个 CPU 系统上看到平均负载为 2.73，6.90，12.98</a>
<a class="sourceLine" id="cb139-13" data-line-number="13">那么说明在过去<span class="ex">1</span> 分钟内，系统有 136% 的超载 (2.73/2=136%)</a>
<a class="sourceLine" id="cb139-14" data-line-number="14">而在过去 <span class="ex">5</span> 分钟内，有 345% 的超载 (6.90/2=345%)</a>
<a class="sourceLine" id="cb139-15" data-line-number="15">而在过去<span class="ex">15</span> 分钟内，有 649% 的超载，(12.98/2=649%)</a>
<a class="sourceLine" id="cb139-16" data-line-number="16">但从整体趋势来看，系统的负载是在逐步的降低。</a></code></pre></div>
<p><strong>8.4 平均负载和CPU使用率有什么关系</strong></p>
<p>Q: 平均负载高了，不就意味着 CPU 使用率高吗？</p>
<p>A: 回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p>
<p>而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p>
<ul>
<li>1.CPU 密集型进程，使用大量 CPU 计算会导致平均负载升高，此时这两者是一致的； （ 视频的转码 加密 计算圆周率 ）</li>
<li>2.I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高； 关注wa</li>
<li>3.大量的 CPU 进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li>
</ul>
<p><strong>总结: 排查步骤</strong></p>
<div class="sourceCode" id="cb140"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb140-1" data-line-number="1">查看步骤:</a>
<a class="sourceLine" id="cb140-2" data-line-number="2"><span class="ex">1.uptime</span>看看负载的情况 （ 超过了 cpu的核心 ）</a>
<a class="sourceLine" id="cb140-3" data-line-number="3"><span class="ex">2.top</span>看是cpu的使用率高 还是 wa等待高 还是内核态占用cpu高 、软中断高 、nice优先级进程占用cpu、</a>
<a class="sourceLine" id="cb140-4" data-line-number="4"><span class="ex">3.top</span>看是哪个进程</a>
<a class="sourceLine" id="cb140-5" data-line-number="5"><span class="ex">4.</span>追踪这个进程的情况。</a>
<a class="sourceLine" id="cb140-6" data-line-number="6"><span class="ex">5.</span>看看是否存在异常日志。</a></code></pre></div>
</body>
</html>
